(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[729],{5458:function(e,n,t){"use strict";t.d(n,{Tl:function(){return makeSample},hu:function(){return assert}});var r=t(5893),a=t(9008),i=t.n(a),s=t(1163),o=t(7294),u=t(4131),d=t.n(u);t(6876);let SampleLayout=e=>{let n=(0,o.useRef)(null),a=(0,o.useMemo)(()=>e.sources.map(e=>{let{name:n,contents:a}=e;return{name:n,...function(e){let n;let a=null;{a=document.createElement("div");let e=t(4631);n=e(a,{lineNumbers:!0,lineWrapping:!0,theme:"monokai",readOnly:!0})}return{Container:function(t){return(0,r.jsx)("div",{...t,children:(0,r.jsx)("div",{ref:t=>{a&&t&&(t.appendChild(a),n.setOption("value",e))}})})}}}(a)}}),e.sources),u=(0,o.useRef)(null),c=(0,o.useMemo)(()=>{if(e.gui){let e=t(4376),n=new e.GUI({autoPlace:!1});return n.domElement.style.position="relative",n.domElement.style.zIndex="1000",n}},[]),l=(0,o.useRef)(null),m=(0,o.useMemo)(()=>{if(e.stats){let e=t(2792);return new e}},[]),h=(0,s.useRouter)(),p=h.asPath.match(/#([a-zA-Z0-9\.\/]+)/),[f,g]=(0,o.useState)(null),[v,x]=(0,o.useState)(null);return(0,o.useEffect)(()=>{if(p?x(p[1]):x(a[0].name),c&&u.current)for(u.current.appendChild(c.domElement);c.__controllers.length>0;)c.__controllers[0].remove();m&&l.current&&(m.dom.style.position="absolute",m.showPanel(1),l.current.appendChild(m.dom));let t={active:!0};try{let r=n.current;if(!r)throw Error("The canvas is not available");let a=e.init({canvas:r,pageState:t,gui:c,stats:m});a instanceof Promise&&a.catch(e=>{console.error(e),g(e)})}catch(e){console.error(e),g(e)}return()=>{t.active=!1}},[]),(0,r.jsxs)("main",{children:[(0,r.jsxs)(i(),{children:[(0,r.jsx)("style",{dangerouslySetInnerHTML:{__html:"\n            .CodeMirror {\n              height: auto !important;\n              margin: 1em 0;\n            }\n\n            .CodeMirror-scroll {\n              height: auto !important;\n              overflow: visible !important;\n            }\n          "}}),(0,r.jsx)("title",{children:"".concat(e.name," - WebGPU Samples")}),(0,r.jsx)("meta",{name:"description",content:e.description}),(0,r.jsx)("meta",{httpEquiv:"origin-trial",content:e.originTrial})]}),(0,r.jsxs)("div",{children:[(0,r.jsx)("h1",{children:e.name}),(0,r.jsx)("a",{target:"_blank",rel:"noreferrer",href:"https://github.com/".concat("Cryszzz/webgpu-samples","/tree/main/").concat(e.filename),children:"See it on Github!"}),(0,r.jsx)("p",{children:e.description}),f?(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("p",{children:"Something went wrong. Do your browser and device support WebGPU?"}),(0,r.jsx)("p",{children:"".concat(f)})]}):null]}),(0,r.jsxs)("div",{className:d().canvasContainer,children:[(0,r.jsx)("div",{style:{position:"absolute",left:10},ref:l}),(0,r.jsx)("div",{style:{position:"absolute",right:10},ref:u}),(0,r.jsx)("canvas",{ref:n})]}),(0,r.jsxs)("div",{children:[(0,r.jsx)("nav",{className:d().sourceFileNav,children:(0,r.jsx)("ul",{children:a.map((e,n)=>(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"#".concat(e.name),"data-active":v==e.name,onClick:()=>{x(e.name)},children:e.name})},n))})}),a.map((e,n)=>(0,r.jsx)(e.Container,{className:d().sourceFileContainer,"data-active":v==e.name},n))]})]})},makeSample=e=>(0,r.jsx)(SampleLayout,{...e});function assert(e,n){if(!e)throw Error(n)}},2729:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return main}});var r=t(6416),a=t(5458);let i={vertexStride:32,positionsOffset:0,normalOffset:12,uvOffset:24};var s="struct Uniforms {\n  viewProjectionMatrix : mat4x4f\n}\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\n\n@group(1) @binding(0) var<uniform> modelMatrix : mat4x4f;\n\nstruct VertexInput {\n  @location(0) position : vec4f,\n  @location(1) normal : vec3f,\n  @location(2) uv : vec2f\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4f,\n  @location(0) normal: vec3f,\n  @location(1) uv : vec2f,\n}\n\n@vertex\nfn vertexMain(input: VertexInput) -> VertexOutput {\n  var output : VertexOutput;\n  output.position = uniforms.viewProjectionMatrix * modelMatrix * input.position;\n  output.normal = normalize((modelMatrix * vec4(input.normal, 0)).xyz);\n  output.uv = input.uv;\n  return output;\n}\n\n@group(1) @binding(1) var meshSampler: sampler;\n@group(1) @binding(2) var meshTexture: texture_2d<f32>;\n\n// Static directional lighting\nconst lightDir = vec3f(1, 1, 1);\nconst dirColor = vec3(1);\nconst ambientColor = vec3f(0.05);\n\n@fragment\nfn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n  let textureColor = textureSample(meshTexture, meshSampler, input.uv);\n\n  // Very simplified lighting algorithm.\n  let lightColor = saturate(ambientColor + max(dot(input.normal, lightDir), 0.0) * dirColor);\n\n  return vec4f(textureColor.rgb * lightColor, textureColor.a);\n}",o="src/sample/renderBundles/main.ts";let init=async e=>{let n,t,a,{canvas:o,pageState:u,gui:d,stats:c}=e,l=await navigator.gpu.requestAdapter(),m=await l.requestDevice();if(!u.active)return;let h={useRenderBundles:!0,asteroidCount:5e3};d.add(h,"useRenderBundles"),d.add(h,"asteroidCount",1e3,1e4,1e3).onChange(()=>{ensureEnoughAsteroids(),updateRenderBundle()});let p=o.getContext("webgpu"),f=window.devicePixelRatio;o.width=o.clientWidth*f,o.height=o.clientHeight*f;let g=navigator.gpu.getPreferredCanvasFormat();p.configure({device:m,format:g,alphaMode:"premultiplied"});let v=m.createShaderModule({code:s}),x=m.createRenderPipeline({layout:"auto",vertex:{module:v,entryPoint:"vertexMain",buffers:[{arrayStride:i.vertexStride,attributes:[{shaderLocation:0,offset:i.positionsOffset,format:"float32x3"},{shaderLocation:1,offset:i.normalOffset,format:"float32x3"},{shaderLocation:2,offset:i.uvOffset,format:"float32x2"}]}]},fragment:{module:v,entryPoint:"fragmentMain",targets:[{format:g}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}}),b=m.createTexture({size:[o.width,o.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),w=m.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});{let e=await fetch("../assets/img/saturn.jpg"),t=await createImageBitmap(await e.blob());n=m.createTexture({size:[t.width,t.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),m.queue.copyExternalImageToTexture({source:t},{texture:n},[t.width,t.height])}{let e=await fetch("../assets/img/moon.jpg"),n=await createImageBitmap(await e.blob());t=m.createTexture({size:[n.width,n.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),m.queue.copyExternalImageToTexture({source:n},{texture:t},[n.width,n.height])}let y=m.createSampler({magFilter:"linear",minFilter:"linear"});function createSphereRenderable(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:16,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,i=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:16,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,i=[],s=[];n=Math.max(3,Math.floor(n)),t=Math.max(2,Math.floor(t));let o=r.R3.create(),u=r.R3.create(),d=r.R3.create(),c=0,l=[];for(let s=0;s<=t;s++){let m=[],h=s/t,p=0;0===s?p=.5/n:s===t&&(p=-.5/n);for(let l=0;l<=n;l++){let f=l/n;if(l==n)r.R3.copy(o,u);else if(0==l||0!=s&&s!==t){let n=e+(Math.random()-.5)*2*a*e;u[0]=-n*Math.cos(f*Math.PI*2)*Math.sin(h*Math.PI),u[1]=n*Math.cos(h*Math.PI),u[2]=n*Math.sin(f*Math.PI*2)*Math.sin(h*Math.PI),0==l&&r.R3.copy(u,o)}i.push(...u),r.R3.copy(u,d),r.R3.normalize(d,d),i.push(...d),i.push(f+p,1-h),m.push(c++)}l.push(m)}for(let e=0;e<t;e++)for(let r=0;r<n;r++){let n=l[e][r+1],a=l[e][r],i=l[e+1][r],o=l[e+1][r+1];0!==e&&s.push(n,a,o),e!==t-1&&s.push(a,i,o)}return{vertices:new Float32Array(i),indices:new Uint16Array(s)}}(e,n,t,a),s=m.createBuffer({size:i.vertices.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(s.getMappedRange()).set(i.vertices),s.unmap();let o=m.createBuffer({size:i.indices.byteLength,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});return new Uint16Array(o.getMappedRange()).set(i.indices),o.unmap(),{vertices:s,indices:o,indexCount:i.indices.length}}function createSphereBindGroup(e,n){let t=m.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(t.getMappedRange()).set(n),t.unmap();let r=m.createBindGroup({layout:x.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:y},{binding:2,resource:e.createView()}]});return r}let M=r._E.create();r._E.identity(M);let S=createSphereRenderable(1);S.bindGroup=createSphereBindGroup(n,M);let B=[createSphereRenderable(.01,8,6,.15),createSphereRenderable(.013,8,6,.15),createSphereRenderable(.017,8,6,.15),createSphereRenderable(.02,8,6,.15),createSphereRenderable(.03,16,8,.15)],P=[S];function ensureEnoughAsteroids(){for(let e=P.length;e<=h.asteroidCount;++e){let n=1.7*Math.random()+1.25,a=Math.random()*Math.PI*2,i=Math.sin(a)*n,s=(Math.random()-.5)*.015,o=Math.cos(a)*n;r._E.identity(M),r._E.translate(M,[i,s,o],M),r._E.rotateX(M,Math.random()*Math.PI,M),r._E.rotateY(M,Math.random()*Math.PI,M),P.push({...B[e%B.length],bindGroup:createSphereBindGroup(t,M)})}}ensureEnoughAsteroids();let T={colorAttachments:[{view:void 0,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:b.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},E=o.width/o.height,R=r._E.perspective(2*Math.PI/5,E,1,100),U=r._E.create(),G=m.createBindGroup({layout:x.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:w}}]});function renderScene(e){e.setPipeline(x),e.setBindGroup(0,G);let n=0;for(let t of P)if(e.setBindGroup(1,t.bindGroup),e.setVertexBuffer(0,t.vertices),e.setIndexBuffer(t.indices,"uint16"),e.drawIndexed(t.indexCount),++n>h.asteroidCount)break}function updateRenderBundle(){let e=m.createRenderBundleEncoder({colorFormats:[g],depthStencilFormat:"depth24plus"});renderScene(e),a=e.finish()}updateRenderBundle(),requestAnimationFrame(function frame(){if(!u.active)return;c.begin();let e=function(){let e=r._E.identity();r._E.translate(e,r.R3.fromValues(0,0,-4),e);let n=Date.now()/1e3;return r._E.rotateZ(e,.1*Math.PI,e),r._E.rotateX(e,.1*Math.PI,e),r._E.rotateY(e,.05*n,e),r._E.multiply(R,e,U),U}();m.queue.writeBuffer(w,0,e.buffer,e.byteOffset,e.byteLength),T.colorAttachments[0].view=p.getCurrentTexture().createView();let n=m.createCommandEncoder(),t=n.beginRenderPass(T);h.useRenderBundles?t.executeBundles([a]):renderScene(t),t.end(),m.queue.submit([n.finish()]),c.end(),requestAnimationFrame(frame)})};var main=()=>(0,a.Tl)({name:"Render Bundles",description:"This example shows how to use render bundles. It renders a large number of\n      meshes individually as a proxy for a more complex scene in order to demonstrate the reduction\n      in JavaScript time spent to issue render commands. (Typically a scene like this would make use\n      of instancing to reduce draw overhead.)",gui:!0,stats:!0,init,sources:[{name:o.substring(25),contents:"import { mat4, vec3 } from 'wgpu-matrix';\nimport { makeSample, SampleInit } from '../../components/SampleLayout';\nimport { createSphereMesh, SphereLayout } from '../../meshes/sphere';\n\nimport meshWGSL from './mesh.wgsl';\n\ninterface Renderable {\n  vertices: GPUBuffer;\n  indices: GPUBuffer;\n  indexCount: number;\n  bindGroup?: GPUBindGroup;\n}\n\nconst init: SampleInit = async ({ canvas, pageState, gui, stats }) => {\n  const adapter = await navigator.gpu.requestAdapter();\n  const device = await adapter.requestDevice();\n\n  if (!pageState.active) return;\n\n  const settings = {\n    useRenderBundles: true,\n    asteroidCount: 5000,\n  };\n  gui.add(settings, 'useRenderBundles');\n  gui.add(settings, 'asteroidCount', 1000, 10000, 1000).onChange(() => {\n    // If the content of the scene changes the render bundle must be recreated.\n    ensureEnoughAsteroids();\n    updateRenderBundle();\n  });\n\n  const context = canvas.getContext('webgpu') as GPUCanvasContext;\n\n  const devicePixelRatio = window.devicePixelRatio;\n  canvas.width = canvas.clientWidth * devicePixelRatio;\n  canvas.height = canvas.clientHeight * devicePixelRatio;\n  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n\n  context.configure({\n    device,\n    format: presentationFormat,\n    alphaMode: 'premultiplied',\n  });\n\n  const shaderModule = device.createShaderModule({\n    code: meshWGSL,\n  });\n\n  const pipeline = device.createRenderPipeline({\n    layout: 'auto',\n    vertex: {\n      module: shaderModule,\n      entryPoint: 'vertexMain',\n      buffers: [\n        {\n          arrayStride: SphereLayout.vertexStride,\n          attributes: [\n            {\n              // position\n              shaderLocation: 0,\n              offset: SphereLayout.positionsOffset,\n              format: 'float32x3',\n            },\n            {\n              // normal\n              shaderLocation: 1,\n              offset: SphereLayout.normalOffset,\n              format: 'float32x3',\n            },\n            {\n              // uv\n              shaderLocation: 2,\n              offset: SphereLayout.uvOffset,\n              format: 'float32x2',\n            },\n          ],\n        },\n      ],\n    },\n    fragment: {\n      module: shaderModule,\n      entryPoint: 'fragmentMain',\n      targets: [\n        {\n          format: presentationFormat,\n        },\n      ],\n    },\n    primitive: {\n      topology: 'triangle-list',\n\n      // Backface culling since the sphere is solid piece of geometry.\n      // Faces pointing away from the camera will be occluded by faces\n      // pointing toward the camera.\n      cullMode: 'back',\n    },\n\n    // Enable depth testing so that the fragment closest to the camera\n    // is rendered in front.\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'less',\n      format: 'depth24plus',\n    },\n  });\n\n  const depthTexture = device.createTexture({\n    size: [canvas.width, canvas.height],\n    format: 'depth24plus',\n    usage: GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n\n  const uniformBufferSize = 4 * 16; // 4x4 matrix\n  const uniformBuffer = device.createBuffer({\n    size: uniformBufferSize,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n\n  // Fetch the images and upload them into a GPUTexture.\n  let planetTexture: GPUTexture;\n  {\n    const response = await fetch('../assets/img/saturn.jpg');\n    const imageBitmap = await createImageBitmap(await response.blob());\n\n    planetTexture = device.createTexture({\n      size: [imageBitmap.width, imageBitmap.height, 1],\n      format: 'rgba8unorm',\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    device.queue.copyExternalImageToTexture(\n      { source: imageBitmap },\n      { texture: planetTexture },\n      [imageBitmap.width, imageBitmap.height]\n    );\n  }\n\n  let moonTexture: GPUTexture;\n  {\n    const response = await fetch('../assets/img/moon.jpg');\n    const imageBitmap = await createImageBitmap(await response.blob());\n\n    moonTexture = device.createTexture({\n      size: [imageBitmap.width, imageBitmap.height, 1],\n      format: 'rgba8unorm',\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    device.queue.copyExternalImageToTexture(\n      { source: imageBitmap },\n      { texture: moonTexture },\n      [imageBitmap.width, imageBitmap.height]\n    );\n  }\n\n  const sampler = device.createSampler({\n    magFilter: 'linear',\n    minFilter: 'linear',\n  });\n\n  // Helper functions to create the required meshes and bind groups for each sphere.\n  function createSphereRenderable(\n    radius: number,\n    widthSegments = 32,\n    heightSegments = 16,\n    randomness = 0\n  ): Renderable {\n    const sphereMesh = createSphereMesh(\n      radius,\n      widthSegments,\n      heightSegments,\n      randomness\n    );\n\n    // Create a vertex buffer from the sphere data.\n    const vertices = device.createBuffer({\n      size: sphereMesh.vertices.byteLength,\n      usage: GPUBufferUsage.VERTEX,\n      mappedAtCreation: true,\n    });\n    new Float32Array(vertices.getMappedRange()).set(sphereMesh.vertices);\n    vertices.unmap();\n\n    const indices = device.createBuffer({\n      size: sphereMesh.indices.byteLength,\n      usage: GPUBufferUsage.INDEX,\n      mappedAtCreation: true,\n    });\n    new Uint16Array(indices.getMappedRange()).set(sphereMesh.indices);\n    indices.unmap();\n\n    return {\n      vertices,\n      indices,\n      indexCount: sphereMesh.indices.length,\n    };\n  }\n\n  function createSphereBindGroup(\n    texture: GPUTexture,\n    transform: Float32Array\n  ): GPUBindGroup {\n    const uniformBufferSize = 4 * 16; // 4x4 matrix\n    const uniformBuffer = device.createBuffer({\n      size: uniformBufferSize,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n    new Float32Array(uniformBuffer.getMappedRange()).set(transform);\n    uniformBuffer.unmap();\n\n    const bindGroup = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(1),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n        {\n          binding: 1,\n          resource: sampler,\n        },\n        {\n          binding: 2,\n          resource: texture.createView(),\n        },\n      ],\n    });\n\n    return bindGroup;\n  }\n\n  const transform = mat4.create() as Float32Array;\n  mat4.identity(transform);\n\n  // Create one large central planet surrounded by a large ring of asteroids\n  const planet = createSphereRenderable(1.0);\n  planet.bindGroup = createSphereBindGroup(planetTexture, transform);\n\n  const asteroids = [\n    createSphereRenderable(0.01, 8, 6, 0.15),\n    createSphereRenderable(0.013, 8, 6, 0.15),\n    createSphereRenderable(0.017, 8, 6, 0.15),\n    createSphereRenderable(0.02, 8, 6, 0.15),\n    createSphereRenderable(0.03, 16, 8, 0.15),\n  ];\n\n  const renderables = [planet];\n\n  function ensureEnoughAsteroids() {\n    for (let i = renderables.length; i <= settings.asteroidCount; ++i) {\n      // Place copies of the asteroid in a ring.\n      const radius = Math.random() * 1.7 + 1.25;\n      const angle = Math.random() * Math.PI * 2;\n      const x = Math.sin(angle) * radius;\n      const y = (Math.random() - 0.5) * 0.015;\n      const z = Math.cos(angle) * radius;\n\n      mat4.identity(transform);\n      mat4.translate(transform, [x, y, z], transform);\n      mat4.rotateX(transform, Math.random() * Math.PI, transform);\n      mat4.rotateY(transform, Math.random() * Math.PI, transform);\n      renderables.push({\n        ...asteroids[i % asteroids.length],\n        bindGroup: createSphereBindGroup(moonTexture, transform),\n      });\n    }\n  }\n  ensureEnoughAsteroids();\n\n  const renderPassDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [\n      {\n        view: undefined, // Assigned later\n\n        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n        loadOp: 'clear',\n        storeOp: 'store',\n      },\n    ],\n    depthStencilAttachment: {\n      view: depthTexture.createView(),\n\n      depthClearValue: 1.0,\n      depthLoadOp: 'clear',\n      depthStoreOp: 'store',\n    },\n  };\n\n  const aspect = canvas.width / canvas.height;\n  const projectionMatrix = mat4.perspective(\n    (2 * Math.PI) / 5,\n    aspect,\n    1,\n    100.0\n  );\n  const modelViewProjectionMatrix = mat4.create();\n\n  const frameBindGroup = device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      {\n        binding: 0,\n        resource: {\n          buffer: uniformBuffer,\n        },\n      },\n    ],\n  });\n\n  function getTransformationMatrix() {\n    const viewMatrix = mat4.identity();\n    mat4.translate(viewMatrix, vec3.fromValues(0, 0, -4), viewMatrix);\n    const now = Date.now() / 1000;\n    // Tilt the view matrix so the planet looks like it's off-axis.\n    mat4.rotateZ(viewMatrix, Math.PI * 0.1, viewMatrix);\n    mat4.rotateX(viewMatrix, Math.PI * 0.1, viewMatrix);\n    // Rotate the view matrix slowly so the planet appears to spin.\n    mat4.rotateY(viewMatrix, now * 0.05, viewMatrix);\n\n    mat4.multiply(projectionMatrix, viewMatrix, modelViewProjectionMatrix);\n\n    return modelViewProjectionMatrix as Float32Array;\n  }\n\n  // Render bundles function as partial, limited render passes, so we can use the\n  // same code both to render the scene normally and to build the render bundle.\n  function renderScene(\n    passEncoder: GPURenderPassEncoder | GPURenderBundleEncoder\n  ) {\n    passEncoder.setPipeline(pipeline);\n    passEncoder.setBindGroup(0, frameBindGroup);\n\n    // Loop through every renderable object and draw them individually.\n    // (Because many of these meshes are repeated, with only the transforms\n    // differing, instancing would be highly effective here. This sample\n    // intentionally avoids using instancing in order to emulate a more complex\n    // scene, which helps demonstrate the potential time savings a render bundle\n    // can provide.)\n    let count = 0;\n    for (const renderable of renderables) {\n      passEncoder.setBindGroup(1, renderable.bindGroup);\n      passEncoder.setVertexBuffer(0, renderable.vertices);\n      passEncoder.setIndexBuffer(renderable.indices, 'uint16');\n      passEncoder.drawIndexed(renderable.indexCount);\n\n      if (++count > settings.asteroidCount) {\n        break;\n      }\n    }\n  }\n\n  // The render bundle can be encoded once and re-used as many times as needed.\n  // Because it encodes all of the commands needed to render at the GPU level,\n  // those commands will not need to execute the associated JavaScript code upon\n  // execution or be re-validated, which can represent a significant time savings.\n  //\n  // However, because render bundles are immutable once created, they are only\n  // appropriate for rendering content where the same commands will be executed\n  // every time, with the only changes being the contents of the buffers and\n  // textures used. Cases where the executed commands differ from frame-to-frame,\n  // such as when using frustrum or occlusion culling, will not benefit from\n  // using render bundles as much.\n  let renderBundle;\n  function updateRenderBundle() {\n    const renderBundleEncoder = device.createRenderBundleEncoder({\n      colorFormats: [presentationFormat],\n      depthStencilFormat: 'depth24plus',\n    });\n    renderScene(renderBundleEncoder);\n    renderBundle = renderBundleEncoder.finish();\n  }\n  updateRenderBundle();\n\n  function frame() {\n    // Sample is no longer the active page.\n    if (!pageState.active) return;\n\n    stats.begin();\n\n    const transformationMatrix = getTransformationMatrix();\n    device.queue.writeBuffer(\n      uniformBuffer,\n      0,\n      transformationMatrix.buffer,\n      transformationMatrix.byteOffset,\n      transformationMatrix.byteLength\n    );\n    renderPassDescriptor.colorAttachments[0].view = context\n      .getCurrentTexture()\n      .createView();\n\n    const commandEncoder = device.createCommandEncoder();\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n    if (settings.useRenderBundles) {\n      // Executing a bundle is equivalent to calling all of the commands encoded\n      // in the render bundle as part of the current render pass.\n      passEncoder.executeBundles([renderBundle]);\n    } else {\n      // Alternatively, the same render commands can be encoded manually, which\n      // can take longer since each command needs to be interpreted by the\n      // JavaScript virtual machine and re-validated each time.\n      renderScene(passEncoder);\n    }\n\n    passEncoder.end();\n    device.queue.submit([commandEncoder.finish()]);\n\n    stats.end();\n\n    requestAnimationFrame(frame);\n  }\n  requestAnimationFrame(frame);\n};\n\nconst RenderBundles: () => JSX.Element = () =>\n  makeSample({\n    name: 'Render Bundles',\n    description: `This example shows how to use render bundles. It renders a large number of\n      meshes individually as a proxy for a more complex scene in order to demonstrate the reduction\n      in JavaScript time spent to issue render commands. (Typically a scene like this would make use\n      of instancing to reduce draw overhead.)`,\n    gui: true,\n    stats: true,\n    init,\n    sources: [\n      {\n        name: __filename.substring(__dirname.length + 1),\n        contents: __SOURCE__,\n      },\n      {\n        name: './mesh.wgsl',\n        contents: meshWGSL,\n        editable: true,\n      },\n      {\n        name: '../../meshes/sphere.ts',\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        contents: require('!!raw-loader!../../meshes/sphere.ts').default,\n      },\n    ],\n    filename: __filename,\n  });\n\nexport default RenderBundles;\n"},{name:"./mesh.wgsl",contents:s,editable:!0},{name:"../../meshes/sphere.ts",contents:t(8557).Z}],filename:o})},4131:function(e){e.exports={canvasContainer:"SampleLayout_canvasContainer__ZTWP5",sourceFileNav:"SampleLayout_sourceFileNav__9Hf73",sourceFileContainer:"SampleLayout_sourceFileContainer__9iti6"}},8557:function(e,n){"use strict";n.Z="import { vec3 } from 'wgpu-matrix';\n\nexport interface SphereMesh {\n  vertices: Float32Array;\n  indices: Uint16Array;\n}\n\nexport const SphereLayout = {\n  vertexStride: 8 * 4,\n  positionsOffset: 0,\n  normalOffset: 3 * 4,\n  uvOffset: 6 * 4,\n};\n\n// Borrowed and simplified from https://github.com/mrdoob/three.js/blob/master/src/geometries/SphereGeometry.js\nexport function createSphereMesh(\n  radius: number,\n  widthSegments = 32,\n  heightSegments = 16,\n  randomness = 0\n): SphereMesh {\n  const vertices = [];\n  const indices = [];\n\n  widthSegments = Math.max(3, Math.floor(widthSegments));\n  heightSegments = Math.max(2, Math.floor(heightSegments));\n\n  const firstVertex = vec3.create();\n  const vertex = vec3.create();\n  const normal = vec3.create();\n\n  let index = 0;\n  const grid = [];\n\n  // generate vertices, normals and uvs\n  for (let iy = 0; iy <= heightSegments; iy++) {\n    const verticesRow = [];\n    const v = iy / heightSegments;\n\n    // special case for the poles\n    let uOffset = 0;\n    if (iy === 0) {\n      uOffset = 0.5 / widthSegments;\n    } else if (iy === heightSegments) {\n      uOffset = -0.5 / widthSegments;\n    }\n\n    for (let ix = 0; ix <= widthSegments; ix++) {\n      const u = ix / widthSegments;\n\n      // Poles should just use the same position all the way around.\n      if (ix == widthSegments) {\n        vec3.copy(firstVertex, vertex);\n      } else if (ix == 0 || (iy != 0 && iy !== heightSegments)) {\n        const rr = radius + (Math.random() - 0.5) * 2 * randomness * radius;\n\n        // vertex\n        vertex[0] = -rr * Math.cos(u * Math.PI * 2) * Math.sin(v * Math.PI);\n        vertex[1] = rr * Math.cos(v * Math.PI);\n        vertex[2] = rr * Math.sin(u * Math.PI * 2) * Math.sin(v * Math.PI);\n\n        if (ix == 0) {\n          vec3.copy(vertex, firstVertex);\n        }\n      }\n\n      vertices.push(...vertex);\n\n      // normal\n      vec3.copy(vertex, normal);\n      vec3.normalize(normal, normal);\n      vertices.push(...normal);\n\n      // uv\n      vertices.push(u + uOffset, 1 - v);\n      verticesRow.push(index++);\n    }\n\n    grid.push(verticesRow);\n  }\n\n  // indices\n  for (let iy = 0; iy < heightSegments; iy++) {\n    for (let ix = 0; ix < widthSegments; ix++) {\n      const a = grid[iy][ix + 1];\n      const b = grid[iy][ix];\n      const c = grid[iy + 1][ix];\n      const d = grid[iy + 1][ix + 1];\n\n      if (iy !== 0) indices.push(a, b, d);\n      if (iy !== heightSegments - 1) indices.push(b, c, d);\n    }\n  }\n\n  return {\n    vertices: new Float32Array(vertices),\n    indices: new Uint16Array(indices),\n  };\n}\n"}}]);