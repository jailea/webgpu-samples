(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[886],{3175:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return main}});var a=n(6416),r=n(5893),i=n(9008),o=n.n(i),s=n(1163),l=n(7294),u=n(4131),c=n.n(u);n(6876);let SampleLayout=e=>{let t=(0,l.useRef)(null),a=(0,l.useMemo)(()=>e.sources.map(e=>{let{name:t,contents:a}=e;return{name:t,...function(e){let t;let a=null;{a=document.createElement("div");let e=n(4631);t=e(a,{lineNumbers:!0,lineWrapping:!0,theme:"monokai",readOnly:!0})}return{Container:function(n){return(0,r.jsx)("div",{...n,children:(0,r.jsx)("div",{ref:n=>{a&&n&&(n.appendChild(a),t.setOption("value",e))}})})}}}(a)}}),e.sources),i=(0,l.useRef)(null),u=(0,l.useMemo)(()=>{if(e.gui){let e=n(4376),t=new e.GUI({autoPlace:!1});return t.domElement.style.position="relative",t.domElement.style.zIndex="1000",t}},[]),d=(0,l.useRef)(null),f=(0,l.useMemo)(()=>{if(e.stats){let e=n(2792);return new e}},[]),p=(0,s.useRouter)(),m=p.asPath.match(/#([a-zA-Z0-9\.\/]+)/),[g,h]=(0,l.useState)(null),[v,x]=(0,l.useState)(null);return(0,l.useEffect)(()=>{if(m?x(m[1]):x(a[0].name),u&&i.current)for(i.current.appendChild(u.domElement);u.__controllers.length>0;)u.__controllers[0].remove();f&&d.current&&(f.dom.style.position="absolute",f.showPanel(1),d.current.appendChild(f.dom));let n={active:!0};try{let a=t.current;if(!a)throw Error("The canvas is not available");let r=e.init({canvas:a,pageState:n,gui:u,stats:f});r instanceof Promise&&r.catch(e=>{console.error(e),h(e)})}catch(e){console.error(e),h(e)}return()=>{n.active=!1}},[]),(0,r.jsxs)("main",{children:[(0,r.jsxs)(o(),{children:[(0,r.jsx)("style",{dangerouslySetInnerHTML:{__html:"\n            .CodeMirror {\n              height: auto !important;\n              margin: 1em 0;\n            }\n\n            .CodeMirror-scroll {\n              height: auto !important;\n              overflow: visible !important;\n            }\n          "}}),(0,r.jsx)("title",{children:"".concat(e.name," - WebGPU Samples")}),(0,r.jsx)("meta",{name:"description",content:e.description}),(0,r.jsx)("meta",{httpEquiv:"origin-trial",content:e.originTrial})]}),(0,r.jsxs)("div",{className:c().canvasContainer,children:[(0,r.jsx)("div",{style:{position:"absolute",left:10},ref:d}),(0,r.jsx)("div",{style:{position:"absolute",right:10},ref:i}),(0,r.jsx)("canvas",{ref:t})]})]})},makeSample=e=>(0,r.jsx)(SampleLayout,{...e});var d="struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n}\n@binding(0) @group(0) var<uniform> uniforms : Uniforms;\n@binding(1) @group(0) var mySampler: sampler;\n@binding(2) @group(0) var myTexture: texture_cube<f32>;\n\nconst skybox_size=3000.0;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec4<f32>,\n}\n\n@vertex\nfn vs_main(\n  @location(0) position : vec4<f32>,\n  @location(1) uv : vec2<f32>\n) -> VertexOutput {\n  var output : VertexOutput;\n  var cam=uniforms.modelViewProjectionMatrix;\n  output.Position =  uniforms.modelViewProjectionMatrix*vec4<f32>(position.xyz*skybox_size,1.0);\n  output.fragUV = uv;\n  output.fragPosition = 0.5 * (position + vec4(1.0, 1.0, 1.0, 1.0));\n  return output;\n}\n\n@fragment\nfn fs_main(\n  @location(0) fragUV: vec2<f32>,\n  @location(1) fragPosition: vec4<f32>\n) -> @location(0) vec4<f32> {\n  var cubemapVec = fragPosition.xyz - vec3(0.5);\n  var color=textureSample(myTexture, mySampler, cubemapVec);\n  return color;\n}";let f=new Float32Array([1,-1,1,1,1,0,1,1,0,1,-1,-1,1,1,0,0,1,1,1,1,-1,-1,-1,1,0,0,0,1,1,0,1,-1,-1,1,1,0,0,1,0,0,1,-1,1,1,1,0,1,1,0,1,-1,-1,-1,1,0,0,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,-1,1,1,1,0,1,1,1,1,1,-1,-1,1,1,0,0,1,1,0,1,1,-1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,-1,-1,1,1,0,0,1,1,0,-1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,0,-1,1,-1,1,0,1,0,1,0,0,-1,1,1,1,0,1,1,1,0,1,1,1,-1,1,1,1,0,1,1,0,-1,-1,1,1,0,0,1,1,0,1,-1,1,1,1,0,1,1,1,1,1,-1,1,-1,1,0,1,0,1,1,0,-1,-1,-1,1,0,0,0,1,0,0,-1,-1,1,1,0,0,1,1,0,1,-1,1,-1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,-1,1,1,1,0,1,1,1,1,1,-1,-1,1,1,0,0,1,1,1,0,-1,-1,1,1,0,0,1,1,1,0,1,-1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,-1,-1,1,1,0,0,1,0,1,-1,-1,-1,1,0,0,0,1,1,1,-1,1,-1,1,0,1,0,1,1,0,1,1,-1,1,1,1,0,1,0,0,1,-1,-1,1,1,0,0,1,0,1,-1,1,-1,1,0,1,0,1,1,0]);async function createSkyboxPipeline(e,t){return e.createRenderPipeline({layout:"auto",vertex:{module:e.createShaderModule({code:d}),entryPoint:"vs_main",buffers:[{arrayStride:40,attributes:[{shaderLocation:0,offset:0,format:"float32x4"},{shaderLocation:1,offset:32,format:"float32x2"}]}]},fragment:{module:e.createShaderModule({code:d}),entryPoint:"fs_main",targets:[{format:t}]},primitive:{topology:"triangle-list",cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}})}async function loadCubemapTexture(e){var t;let n=["../assets/img/cubemap/sky2px.png","../assets/img/cubemap/sky2nx.png","../assets/img/cubemap/sky2py.png","../assets/img/cubemap/sky2ny.png","../assets/img/cubemap/sky2pz.png","../assets/img/cubemap/sky2nz.png"].map(async e=>{let t=await fetch(e);return createImageBitmap(await t.blob())}),a=await Promise.all(n);t=e.createTexture({dimension:"2d",size:[a[0].width,a[0].height,6],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let n=0;n<a.length;n++){let r=a[n];e.queue.copyExternalImageToTexture({source:r},{texture:t,origin:[0,0,n]},[r.width,r.height])}return t}async function renderSkybox(e,t,n,a,r,i,o){e.queue.writeBuffer(a,0,o.buffer,o.byteOffset,o.byteLength),i.setPipeline(t),i.setVertexBuffer(0,n),i.setBindGroup(0,r),i.draw(36)}var p='////////////////////////////////////////////////////////////////////////////////\n// Utilities\n////////////////////////////////////////////////////////////////////////////////\nvar<private> rand_seed : vec2<f32>;\nconst albedo = vec3<f32>(0.9,0.7,0.4);\nconst PI:f32=3.1416926535928;\nstruct SimulationCS {\n    MeasurementAltitude: f32,\n    TSnowA:f32,\n    TSnowB:f32,\n    TMeltA:f32,\n    TMeltB:f32,\n    k_e:f32,\n    k_m:f32,\n};\nconst SimulationCSConstants: SimulationCS = SimulationCS(0.0,0.0,2.0,-5.0,-2.0,0.2,4.0);\n\nstruct WeatherData\n{\n	Temperature:f32,\n	Precipitation:f32,\n};\n\nstruct SimulationCSVar {\n    Timesteps: i32,\n    CurrentSimulationStep: i32,\n    HourOfDay: i32,\n    DayOfYear: i32,\n};\n\nconst SimulationCSVariables: SimulationCSVar = SimulationCSVar(0,0,12,148);\n\nfn init_rand(invocation_id : u32, seed : vec4<f32>) {\n  rand_seed = seed.xz;\n  rand_seed = fract(rand_seed * cos(35.456+f32(invocation_id) * seed.yw));\n  rand_seed = fract(rand_seed * cos(41.235+f32(invocation_id) * seed.xw));\n}\n\nfn rand() -> f32 {\n  rand_seed.x = fract(cos(dot(rand_seed, vec2<f32>(23.14077926, 232.61690225))) * 136.8168);\n  rand_seed.y = fract(cos(dot(rand_seed, vec2<f32>(54.47856553, 345.84153136))) * 534.7645);\n  return rand_seed.y;\n}\n\nfn Func2(L: f32, D: f32) -> f32 {\n    return acos(clamp(-tan(L) * tan(D), -1.0, 1.0));\n}\n\nfn Func3(V: f32, W: f32, X: f32, Y: f32, R1: f32, D: f32) -> f32 {\n    return R1 * (sin(D) * sin(W) * (X - Y) * (12.0 / PI) +\n                 cos(D) * cos(W) * (sin(X + V) - sin(Y + V)) * (12.0 / PI));\n}\n\nfn SolarRadiationIndex(I: f32, A: f32, L0: f32, J: f32) -> vec3<f32>{\n    var L1: f32 = acos(cos(I) * sin(L0) + sin(I) * cos(L0) * cos(A));\n    var D1: f32 = cos(I) * cos(L0) - sin(I) * sin(L0) * cos(A);\n    var L2: f32 = atan(sin(I) * sin(A) / (cos(I) * cos(L0) - sin(I) * sin(L0) * cos(A)));\n\n    var D: f32 = 0.007 - 0.4067 * cos((J + 10.0) * 0.0172);\n    var E: f32 = 1.0 - 0.0167 * cos((J - 3.0) * 0.0172);\n\n    let R0: f32 = 1.95;\n    var R1: f32 = 60.0 * R0 / (E * E);\n\n    var T: f32;\n    T = Func2(L1, D);\n    var T7: f32 = T - L2;\n    var T6: f32 = -T - L2;\n    T = Func2(L0, D);\n    var T1: f32 = T;\n    var T0: f32 = -T;\n    var T3: f32 = min(T7, T1);\n    var T2: f32 = max(T6, T0);\n\n    var T4: f32 = T2 * (12.0 / PI);\n    var T5: f32 = T3 * (12.0 / PI);\n\n    if (T3 < T2) {\n        T2 = 0.0;\n        T3 = 0.0;\n    }\n\n    T6 = T6 + PI * 2.0;\n\n    var R4: f32;\n    if (T6 < T1) {\n        var T8: f32 = T6;\n        var T9: f32 = T1;\n        R4 = Func3(L2, L1, T3, T2, R1, D) + Func3(L2, L1, T9, T8, R1, D);\n    } else {\n        T7 = T7 - PI * 2.0;\n\n        if (T7 > T0) {\n            var T8: f32 = T0;\n            var T9: f32 = T0;\n            R4 = Func3(L2, L1, T3, T2, R1, D) + Func3(L2, L1, T9, T8, R1, D);\n        } else {\n            R4 = Func3(L2, L1, T3, T2, R1, D);\n        }\n    }\n\n    var R3: f32 = Func3(0.0, L0, T1, T0, R1, D);\n\n    return vec3<f32>(T4,T5,R4 / R3);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Vertex shader\n////////////////////////////////////////////////////////////////////////////////\nstruct RenderParams {\n  modelViewProjectionMatrix : mat4x4<f32>,\n  right : vec3<f32>,\n  up : vec3<f32>\n}\n@binding(0) @group(0) var<uniform> render_params : RenderParams;\n// @binding(1) @group(0) var fragtexture : texture_storage_2d<f32, read>;\n@binding(1) @group(0) var fragtexture : texture_2d<f32>;\n@binding(2) @group(0) var origtexture : texture_2d<f32>;\n@binding(3) @group(0) var<uniform>  grid : vec2<f32>;\n@binding(4) @group(0) var heighttexture : texture_2d<f32>;\n@binding(5) @group(0) var<storage, read> maxSnow : array<u32>; // TODO: BINDING NUMBER\n\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) normal : f32,\n  @location(2) uv: vec2<f32>, // -1..+1\n}\n\nstruct VertexOutput {\n  @location(0) position: vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) uv : vec2<f32>, // -1..+1\n\n  @builtin(position) Position : vec4<f32>,\n}\nconst heightMul:f32=0.08;\n@vertex\nfn vs_main(in : VertexInput,\n            @builtin(instance_index) instance: u32) -> VertexOutput {\n  //var quad_pos = mat2x3<f32>(render_params.right, render_params.up) * in.quad_pos;\n  //var position = in.position;\n\n  // var in_position_height_offset = vec3<f32>(in.position.x, in.position.y + testColorMax.x, in.position.z);\n\n  var out : VertexOutput;\n  \n  var textDim=vec2<i32>(textureDimensions(heighttexture));\n  //textDim=vec2<i32>(5,5);\n  let i = i32(instance);\n  let cell = vec2<i32>(i % (textDim.x - 1), i / (textDim.x - 1)); // should one be textDim.y - 1?\n  let p0:vec3<f32>=vec3<f32>(0.0,textureLoad(heighttexture,cell,0).x*heightMul,0.0);\n  let p1:vec3<f32>=vec3<f32>(grid.x,textureLoad(heighttexture,vec2<i32>(cell.x+1,cell.y),0).x*heightMul,0.0);\n  let p2:vec3<f32>=vec3<f32>(0.0,textureLoad(heighttexture,vec2<i32>(cell.x,cell.y+1),0).x*heightMul,grid.y);\n  let p3:vec3<f32>=vec3<f32>(grid.x,textureLoad(heighttexture,vec2<i32>(cell.x+1,cell.y+1),0).x*heightMul,grid.y);\n  /*let p0:vec3<f32>=vec3<f32>(0.0,0.0,0.0);\n  let p1:vec3<f32>=vec3<f32>(grid.x,30.0,0.0);\n  let p2:vec3<f32>=vec3<f32>(0.0,30.0,grid.y);\n  let p3:vec3<f32>=vec3<f32>(grid.x,90.0,grid.y);*/\n  var normal:vec3<f32>;\n  if(in.normal==0.0){\n    normal=normalize(cross(p2-p0,p3-p0));\n  }else{\n    normal=normalize(cross(p3-p0,p1-p0));\n  }\n  var coord:vec2<i32>=cell;\n  if(in.position.x > 0.0){\n    coord.x+=1;\n  }\n  if(in.position.z > 0.0){\n    coord.y+=1;\n  }\n  //let cell = vec2<i32>(i % 2, i / 2);\n  let cellOffset = vec2<f32>(cell-textDim/2)*grid;\n  var gridPos:vec2<f32> = (in.position.xz) * (grid/2.0) + cellOffset;\n  \n  // Calculate displacement from snow\n  var fragDim=vec2<i32>(textureDimensions(fragtexture).xy);\n  var fragCoord : vec2<i32>=vec2<i32>(0,0);\n  fragCoord.x=i32(f32(fragDim.x)*f32((coord.x / (textDim.x - 1)) * fragDim.x)); // TODO: What should be uv for the overall grid?\n  fragCoord.y=i32(f32(fragDim.y)*f32((coord.y / (textDim.y - 1)) * fragDim.y)); // TODO: What should be uv for the overall grid? \n  var testcolor = textureLoad(fragtexture, fragCoord.xy, 0); \n  var testColorMax = clamp(testcolor * 100 / (f32(maxSnow[0])), vec4(0.0), vec4(75)); // change these values so that they can be multiplied by heightMul\n\n  var height:f32=textureLoad(heighttexture,coord,0).x;\n  out.Position = render_params.modelViewProjectionMatrix * vec4<f32>(gridPos.x,(height + testColorMax.x)*heightMul,gridPos.y, 1.0);\n  out.position=vec3<f32>(gridPos.x,(height+ testColorMax.x)*heightMul,gridPos.y);\n  out.normal =normal;\n  out.uv = vec2<f32>(f32(coord.x)/f32(textDim.x),f32(coord.y)/f32(textDim.y));\n  return out;\n}\n\n/*\n@vertex\nfn main(\n  @location(0) position: vec3<f32>,\n  @location(1) normal: vec3<f32>,\n  @location(2) uvs: vec2<f32>,\n) -> VertexOutput {\n  var output : VertexOutput;\n\n  //output.position = render_params.modelViewProjectionMatrix * vec4(position, 1.0);\n  output.position = vec4(position, 1.0);\n  //output.fragPos = output.Position.xyz;\n  //output.fragNorm = normal;\n  //output.fragUV=uvs;\n  return output;\n}*/\n\n////////////////////////////////////////////////////////////////////////////////\n// Fragment shader\n////////////////////////////////////////////////////////////////////////////////\n\nconst lightPos : vec3<f32>= vec3<f32> (50.0, 100.0, -100.0);\nconst lightDir : vec3<f32>= vec3<f32> (1.0, -1.0, 0.0);\nconst ambientFactor = 0.4;\n/*\nCRYSTAL: There are two texture bind to fragment shader\nfragtexture: the texture buffer that got from compute pipeline\norigtexture: the texture buffer that is the original texture\n\nThey varies in resolution, better to interpolate values for final result, but rn, change between these two to test whether we have correct computation.\n*/\n\n@fragment\nfn fs_main(in : VertexOutput) -> @location(0) vec4<f32> {\n  var test=render_params.modelViewProjectionMatrix;\n  var textDim=vec2<i32>(textureDimensions(fragtexture).xy);\n  var textorigDim=vec2<i32>(textureDimensions(origtexture).xy);\n  var coord : vec2<i32>=vec2<i32>(0,0);\n\n  //CRYSTAL: change following three lines of code for testing different textures\n  coord.x=i32(f32(textDim.x)*in.uv.x);\n  coord.y=i32(f32(textDim.y)*in.uv.y);\n  var testcolor = textureLoad(fragtexture, coord.xy, 0);\n\n  coord.x=i32(f32(textorigDim.x)*in.uv.x);\n  coord.y=i32(f32(textorigDim.y)*in.uv.y);\n  var origcolor = textureLoad(origtexture, coord.xy, 0);\n\n  // this should be maxSnow[0] instead of maxSnow[0] * 0.4, but leaving it here until debugged\n  // var testColorMaxFirst = clamp(testcolor / (f32(maxSnow[0]) * 0.35), vec4(0.0), vec4(1.0));\n  var testColorMaxFirst = testcolor / (f32(maxSnow[0]) * 0.35);\n  var expFactors = vec4<f32>(2.0);\n  var testColorMaxScaled =  testColorMaxFirst * 0.7 + 0.27;\n  var testcolorMax = clamp(testColorMaxScaled, vec4(0.0), vec4(1.0));\n  // var out_color = testcolorMax;\n  var out_color = (1.0-testcolorMax.x)*origcolor+testcolorMax.x*testcolorMax;\n  // var out_color = vec4(maxSnow[0]);\n\n  let lambertFactor = max(dot(normalize(-lightDir), in.normal), 0.0);\n  let lightingFactor = min(ambientFactor + lambertFactor, 1.0);\n  var color = vec4(lightingFactor*out_color.xyz,1.0);\n  // var color = vec4(out_color.xyz,1.0);\n  // Apply a circular particle alpha mask\n  //color.a = color.a * max(1.0 - length(in.quad_pos), 0.0);\n  return color;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Simulation Compute shader\n////////////////////////////////////////////////////////////////////////////////\nstruct SimulationParams {\n  deltaTime : f32,\n  seed : vec4<f32>,\n  Temperature: f32,\n  Precipitation: f32,\n  HourOfDay: f32,\n  DayOfYear: f32,\n}\n\nstruct Particle {\n  position : vec3<f32>,\n  lifetime : f32,\n  color    : vec4<f32>,\n  velocity : vec3<f32>,\n}\nstruct Particles {\n  particles : array<Particle>,\n}\n\n/*\nAspect: number[],\nInclination: number[],\nAltitude: number[],\nLatitude: number[],\nArea: number[],\nAreaXZ: number[],\nSnowWaterEquivalent: number[],\nInterpolatedSWE: number[],\nSnowAlbedo: number[],\nDaysSinceLastSnowfall: number[],\nCurvature: number[],*/\nstruct Cell { \n  Aspect: f32,\n  Inclination: f32,\n  Altitude: f32,\n  Latitude: f32,\n  Area: f32,\n  AreaXY: f32,\n  SnowWaterEquivalent: f32,\n  InterpolatedSWE: f32,\n  SnowAlbedo: f32,\n  DaysSinceLastSnowfall: f32,\n  Curvature: f32,\n  Padding:f32,\n}\nstruct Cells {\n  cells : array<Cell>,\n}\n\n@binding(0) @group(0) var<uniform> sim_params : SimulationParams;\n@binding(1) @group(0) var<storage, read_write> data : Cells;\n@binding(2) @group(0) var texture : texture_2d<f32>;\n@binding(3) @group(0) var texture2 : texture_storage_2d<rgba32float, write>;\n@binding(4) @group(0) var<storage, read_write> maxSnowStorage : array<atomic<u32>>;\n\n@compute @workgroup_size(8,8)\nfn simulate(@builtin(global_invocation_id) global_invocation_id : vec3<u32>) {\n    \n    var textDim=vec2<i32>(textureDimensions(texture).xy);\n    var text2Dim=vec2<i32>(textureDimensions(texture2).xy);\n    var coord : vec2<i32>=vec2<i32>(global_invocation_id.xy);\n    var idx: u32= global_invocation_id.x*textureDimensions(texture2).y+global_invocation_id.y;\n    //var idx: u32= global_invocation_id.x;\n\n    init_rand(idx, sim_params.seed);\n    var loadcoord : vec2<i32>=vec2<i32>(0,0);\n    loadcoord.x=i32(coord.x*textDim.x/text2Dim.x);\n    loadcoord.y=i32(coord.y*textDim.y/text2Dim.y);\n    //CRYSTAL: color from original texture\n    var color = textureLoad(texture, loadcoord, 0);\n    \n    //CRYSTAL: here is example of how to store color to texture, just modify color.xyz to change color\n    //textureStore(texture2, vec2<i32>(coord.xy), vec4<f32>(color.xyz,1.0));\n\n\n    //CRYSTAL: starting from this part, use the same code from that unreal project\n    var celldata = data.cells[idx];\n    \n    var areaSquareMeters:f32 = celldata.AreaXY * 10; // m^2 Each cell is constant 2000m^2 for now\n    // var areaSquareMetersPrecip:f32 = celldata.AreaXY / 1000; // m^2\n\n    //for (var time:i32 = 0; time < SimulationCSVariables.Timesteps; time=time+1) {\n    var stationAltitudeOffset:f32 = celldata.Altitude - SimulationCSConstants.MeasurementAltitude;\n    var temperatureLapse:f32 = - (0.5 * stationAltitudeOffset) / (100.0 * 100.0);\n\n    var tAir:f32= sim_params.Temperature + temperatureLapse; // degree Celsius\n\n    var precipitationLapse:f32= 10.0 / 24.0 * stationAltitudeOffset / (100.0 * 1000.0);\n        // const precipitationLapse: number = 0;\n    var precipitation:f32 = sim_params.Precipitation;\n\n    celldata.DaysSinceLastSnowfall += 1.0 / 24.0;\n    \n      // Apply precipitation\n    if (precipitation > 0.0) {\n        precipitation += precipitationLapse;\n        celldata.DaysSinceLastSnowfall = 0.0;\n\n        // New snow/rainfall\n        //let rain: boolean = tAir > SimulationCSConstants.TSnowB;\n\n        if (tAir > SimulationCSConstants.TSnowB) {\n            celldata.SnowAlbedo = 0.4; // New rain drops the albedo to 0.4\n        } else {\n            // Variable lapse rate as described in "A variable lapse rate snowline model for the Remarkables, Central Otago, New Zealand"\n            var snowRate:f32= max(0.0, 1.0 - (tAir - SimulationCSConstants.TSnowA) / (SimulationCSConstants.TSnowB - SimulationCSConstants.TSnowA));\n\n            celldata.SnowWaterEquivalent += (precipitation * areaSquareMeters * snowRate); // l/m^2 * m^2 = l\n            celldata.SnowAlbedo = 0.8; // New snow sets the albedo to 0.8\n        }\n    }\n      \n      // Apply melt\n    if (celldata.SnowWaterEquivalent > 0.0) {\n        if (celldata.DaysSinceLastSnowfall >= 0.0) {\n            // @TODO is time T the degree-days or the time since the last snowfall?\n            celldata.SnowAlbedo = 0.4 * (1.0 + exp(-SimulationCSConstants.k_e * celldata.DaysSinceLastSnowfall));\n        }\n\n        // Temperature higher than melt threshold and cell contains snow\n        if (tAir > SimulationCSConstants.TMeltA) {\n            var dayNormalization: f32 = 1.0 / 24.0; // day\n\n            // Radiation Index\n            var output: vec3<f32> = SolarRadiationIndex(celldata.Inclination,celldata.Aspect, celldata.Latitude, f32(SimulationCSVariables.DayOfYear)); // 1\n\n            var r_i:f32=output.z;\n            var T4: f32=output.x;\n            var T5: f32=output.y;\n\n            // Diurnal approximation\n            var t: i32 = SimulationCSVariables.HourOfDay;\n            var D: f32 = abs(T4) + abs(T5);\n            var r_i_t: f32 = max(PI * r_i / 2.0 * sin(PI * f32(t) / D - abs(T4) / PI), 0.0);\n            // var r_i_t: f32 =5.0;\n            // Melt factor\n            // @TODO melt factor test\n            var vegetationDensity: f32 = 0.0;\n            var k_v: f32 = exp(-4.0 * vegetationDensity); // 1\n            var c_m: f32 = SimulationCSConstants.k_m * k_v * r_i_t * (1.0 - celldata.SnowAlbedo) * dayNormalization * areaSquareMeters; // l/m^2/C�/day * day * m^2 = l/m^2 * 1/day * day * m^2 = l/C�\n            var meltFactor: f32;\n            if(tAir < SimulationCSConstants.TMeltB){\n                meltFactor=2 * (tAir - SimulationCSConstants.TMeltA) * (tAir - SimulationCSConstants.TMeltA) / (SimulationCSConstants.TMeltB - SimulationCSConstants.TMeltA);\n            }else{\n                meltFactor=2 * (tAir - SimulationCSConstants.TMeltA);\n            }\n\n            // Added factor to speed up melting\n            var m: f32 = c_m * meltFactor; // l/C� * C� = l \n\n            // Apply melt\n            celldata.SnowWaterEquivalent -= m;\n            celldata.SnowWaterEquivalent = max(0.0, celldata.SnowWaterEquivalent);\n        }\n    }\n    var slope = degrees(celldata.Inclination);\n    var f = select(slope / 60, 0, slope < 10.0);\n    // var f = select(0, slope / 60, slope < 15.0);\n	  var a3 = 50.0;\n\n    // celldata.InterpolatedSWE = celldata.SnowWaterEquivalent * (1 - f);\n    celldata.InterpolatedSWE = max(celldata.SnowWaterEquivalent * (1 - f) * (1 + a3 * celldata.Curvature), 0.0);\n    // celldata.InterpolatedSWE = celldata.SnowWaterEquivalent;\n    //celldata.Curvature-=0.001;\n    data.cells[idx] = celldata;\n    //var output_color: f32=celldata.SnowAlbedo;\n    var output_color: f32=celldata.InterpolatedSWE * 0.7;\n    atomicMax(&maxSnowStorage[0],u32(output_color));\n    var debug_color_y: f32 = f32(coord.y) / f32(textureDimensions(texture2).y);\n    var debug_color_x: f32 = f32(coord.x) / f32(textureDimensions(texture2).x);\n    \n    textureStore(texture2, vec2<i32>(coord.xy), vec4<f32>(output_color,output_color,output_color,1.0));\n\n  // (11,6),(11,7)\n  // (9,15),(9,16),(9,17)\n\n  // Apply gravity\n  /*particle.velocity.z = particle.velocity.z - sim_params.deltaTime * 0.5;\n\n  // Basic velocity integration\n  particle.position = particle.position + sim_params.deltaTime * particle.velocity;\n\n  // Age each particle. Fade out before vanishing.\n  particle.lifetime = particle.lifetime - sim_params.deltaTime;\n  particle.color.a = smoothstep(0.0, 0.5, particle.lifetime);\n\n  // If the lifetime has gone negative, then the particle is dead and should be\n  // respawned.\n  if (particle.lifetime < 0.0) {\n    // Use the probability map to find where the particle should be spawned.\n    // Starting with the 1x1 mip level.\n    \n    for (var level = u32(textureNumLevels(texture) - 1); level > 0; level--) {\n      // Load the probability value from the mip-level\n      // Generate a random number and using the probabilty values, pick the\n      // next texel in the next largest mip level:\n      //\n      // 0.0    probabilites.r    probabilites.g    probabilites.b   1.0\n      //  |              |              |              |              |\n      //  |   TOP-LEFT   |  TOP-RIGHT   | BOTTOM-LEFT  | BOTTOM_RIGHT |\n      //\n      let probabilites = textureLoad(texture, coord, level);\n      let value = vec4<f32>(rand());\n      let mask = (value >= vec4<f32>(0.0, probabilites.xyz)) & (value < probabilites);\n      coord = coord * 2;\n      coord.x = coord.x + select(0, 1, any(mask.yw)); // x  y\n      coord.y = coord.y + select(0, 1, any(mask.zw)); // z  w\n    }\n    let uv = vec2<f32>(coord) / vec2<f32>(textureDimensions(texture));\n    particle.position = vec3<f32>((uv - 0.5) * 3.0 * vec2<f32>(1.0, -1.0), 0.0);\n    particle.color = textureLoad(texture, coord, 0);\n    textureStore(texture2, vec2<i32>(coord.xy), vec4<f32>(0.0,0.0,0.0,0.0));\n    particle.velocity.x = (rand() - 0.5) * 0.1;\n    particle.velocity.y = (rand() - 0.5) * 0.1;\n    particle.velocity.z = rand() * 0.3;\n    particle.lifetime = 0.5 + rand() * 3.0;\n  }*/\n\n  // Store the new particle value\n  //data.particles[idx] = particle;\n}',m="struct UBO {\n  width : u32,\n}\n\nstruct Buffer {\n  weights : array<f32>,\n}\n\n@binding(0) @group(0) var<uniform> ubo : UBO;\n@binding(1) @group(0) var<storage, read> buf_in : Buffer;\n@binding(2) @group(0) var<storage, read_write> buf_out : Buffer;\n@binding(3) @group(0) var tex_in : texture_2d<f32>;\n@binding(3) @group(0) var tex_out : texture_storage_2d<rgba8unorm, write>;\n\n\n////////////////////////////////////////////////////////////////////////////////\n// import_level\n//\n// Loads the alpha channel from a texel of the source image, and writes it to\n// the buf_out.weights.\n////////////////////////////////////////////////////////////////////////////////\n@compute @workgroup_size(64)\nfn import_level(@builtin(global_invocation_id) coord : vec3<u32>) {\n  _ = &buf_in;\n  let offset = coord.x + coord.y * ubo.width;\n  buf_out.weights[offset] = textureLoad(tex_in, vec2<i32>(coord.xy), 0).w;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// export_level\n//\n// Loads 4 f32 weight values from buf_in.weights, and stores summed value into\n// buf_out.weights, along with the calculated 'probabilty' vec4 values into the\n// mip level of tex_out. See simulate() in particle.wgsl to understand the\n// probability logic.\n////////////////////////////////////////////////////////////////////////////////\n@compute @workgroup_size(64)\nfn export_level(@builtin(global_invocation_id) coord : vec3<u32>) {\n  if (all(coord.xy < vec2<u32>(textureDimensions(tex_out)))) {\n    let dst_offset = coord.x    + coord.y    * ubo.width;\n    let src_offset = coord.x*2u + coord.y*2u * ubo.width;\n\n    let a = buf_in.weights[src_offset + 0u];\n    let b = buf_in.weights[src_offset + 1u];\n    let c = buf_in.weights[src_offset + 0u + ubo.width];\n    let d = buf_in.weights[src_offset + 1u + ubo.width];\n    let sum = dot(vec4<f32>(a, b, c, d), vec4<f32>(1.0));\n\n    buf_out.weights[dst_offset] = sum / 4.0;\n\n    let probabilities = vec4<f32>(a, a+b, a+b+c, sum) / max(sum, 0.0001);\n    textureStore(tex_out, vec2<i32>(coord.xy), probabilities);\n  }\n}\n";function getDayOfYear(e){return Math.floor(e/1e3%365)}var g=n(8175);let lerp=(e,t,n)=>(1-n)*e+n*t;var h=[0,0];async function getHeightData(e){let t=await fetch(e),n=await (0,g.mK)(await t.blob()),a=await n.getImage(),r=await a.readRasters();console.log(r);let{ModelPixelScale:i,ModelTiepoint:o}=a.fileDirectory,[s,l,u]=i,[c,d,f,p,m,v]=o;l=-l;let x=[-p/s,1/s,0,-m/l,0,1/l],b=r[0],[w,y,T,P]=a.getBoundingBox(),S=lerp(y,P,Math.random()),_=lerp(w,T,Math.random()),[C,E]=function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],round=e=>a?0|e:e;return[round(n[0]+n[1]*e+n[2]*t),round(n[3]+n[4]*e+n[5]*t)]}(_,S,x,!0),{width:B,0:A}=r,U=Math.floor(B/(T-w)*(P-y));h[0]=B,h[1]=U;let M=new Float32Array(b);return M}var v=n(7160),x=n(1437),b=[0,0];async function loadAndUseHeightData(){let e=await getHeightData("../assets/img/file/everest.tif");return b[0]=h[0],b[1]=h[1],console.log("numberarray"),console.log(h),e}async function generateTerrainMesh(){let e=await loadAndUseHeightData(),t=b[1],n=b[0],r=2*Math.floor((Math.floor(t/2)-1)/2)+1,i=2*Math.floor((Math.floor(n/2)-1)/2)+1;console.log("verticesPerRow"+r),console.log("verticesPerColumn"+i);let o=[],s=[];for(let a=0;a<2*i;a+=2)for(let i=0;i<2*r;i+=2){let l=e[a*t+i];o.push([(a-n/2)*1,l/100,(i-t/2)*1]),s.push([a/(2*r)*1,1-i/(2*r)*1])}let l=[];for(let e=0;e<i-1;e++)for(let t=0;t<r-1;t++){let n=e*r+t,a=n+1,i=n+r,o=i+1;l.push([n,a,i]),l.push([a,o,i])}let u={positions:o,triangles:l,normals:[],uvs:s,height:r,width:i};return u.normals=function(e,t){let n=e.map(()=>[0,0,0]);return t.forEach(t=>{let[r,i,o]=t,s=e[r],l=e[i],u=e[o],c=a.R3.subtract(l,s),d=a.R3.subtract(u,s);a.R3.normalize(c,c),a.R3.normalize(d,d);let f=a.R3.cross(c,d);a.R3.add(n[r],f,n[r]),a.R3.add(n[i],f,n[i]),a.R3.add(n[o],f,n[o])}),n.forEach(e=>{a.R3.normalize(e,e)}),n}(o,l),u}async function getTerrainMesh(){return await generateTerrainMesh()}let normalizeAngle360=e=>(e%=360)<0?e+2*Math.PI:e;async function getTerrainCells(e){return await generateTerrainCells(e)}function getCellIndex(e,t,n,a){let r=e*a+t;return r>=0&&r<n*a?r:-1}async function generateTerrainCells(e){let t=e.width,n=e.height,a=e.positions.length;console.log("grid_size "+a),console.log("side_width "+(t-1)),console.log("side_height "+(n-1));let r={P0:Array(a),P1:Array(a),P2:Array(a),P3:Array(a),Aspect:Array(a),Inclination:Array(a),Altitude:Array(a),Latitude:Array(a),Area:Array(a),AreaXZ:Array(a),SnowWaterEquivalent:Array(a),InterpolatedSWE:Array(a),SnowAlbedo:Array(a),DaysSinceLastSnowfall:Array(a),Curvature:Array(a),Size:(n-1)*(t-1)},i=0;for(let a=0;a<t-1;a++)for(let t=0;t<n-1;t++){let o=a*(n-1)+t;r.P0[o]=e.positions[a*n+t],r.P1[o]=e.positions[a*n+t+1],r.P2[o]=e.positions[(a+1)*n+t],r.P3[o]=e.positions[(a+1)*n+t+1];let s=v.al(r.P0[o][0],r.P0[o][1],r.P0[o][2]),l=v.al(r.P1[o][0],r.P1[o][1],r.P1[o][2]),u=v.al(r.P2[o][0],r.P2[o][1],r.P2[o][2]),c=v.al(r.P3[o][0],r.P3[o][1],r.P3[o][2]),d=v.kC(v.Ue(),v.$X(v.Ue(),l,s),v.$X(v.Ue(),u,s)),f=v.al((s[0]+l[0]+u[0]+c[0])/4,(s[1]+l[1]+u[1]+c[1])/4,(s[2]+l[2]+u[2]+c[2])/4);r.Altitude[o]=f[1];let p=v.$X(v.Ue(),s,u),m=v.$X(v.Ue(),l,u),g=x.al(p[0],p[2]),h=x.al(m[0],m[2]);r.Area[o]=Math.abs(v.Zh(v.kC(v.Ue(),p,p))/2+v.Zh(v.kC(v.Ue(),m,p))/2),r.AreaXZ[o]=Math.abs(x.kC(v.Ue(),g,g)[2]/2+x.kC(v.Ue(),h,g)[2]/2);let b=v.$X(v.Ue(),u,s),w=v.al(b[0],b[2],0);r.Inclination[o]=1e-5>v.Zh(b)?0:Math.acos(v.AK(b,w)/(v.Zh(b)*v.Zh(w))),r.Latitude[o]=47*Math.PI/180;let y=x.al(d[0],d[2]),T=x.al(1,0),P=x.AK(y,T),S=y[0]*T[1]-y[1]*T[0];r.Aspect[o]=Math.atan2(S,P),r.Aspect[o]=normalizeAngle360(r.Aspect[o]);let _=0;if(r.Altitude[o]/100>3300){let e=r.Area[o]/1e4,t=(2.5+r.Altitude[o]/100*.001)*e;console.log("initial swe: "+t),i=Math.max((_=t)/e,i)}r.SnowWaterEquivalent[o]=_}let o=t-1,s=n-1;for(let e=0;e<o;e++)for(let t=0;t<s;t++){let n=e*s+t,a=Array(8);if(a[0]=getCellIndex(e,t-1,o,s),a[1]=getCellIndex(e+1,t-1,o,s),a[2]=getCellIndex(e+1,t,o,s),a[3]=getCellIndex(e+1,t+1,o,s),a[4]=getCellIndex(e,t+1,o,s),a[5]=getCellIndex(e-1,t+1,o,s),a[6]=getCellIndex(e-1,t,o,s),a[7]=getCellIndex(e-1,t-1,o,s),-1==a[0]||-1==a[1]||-1==a[2]||-1==a[3]||-1==a[4]||-1==a[5]||-1==a[6]||-1==a[7]){r.Curvature[n]=5e-4;continue}r.Altitude[a[1]];let i=r.Altitude[a[0]]/100;r.Altitude[a[7]];let l=r.Altitude[a[2]]/100,u=r.Altitude[n]/100,c=r.Altitude[a[6]]/100;r.Altitude[a[3]];let d=r.Altitude[a[4]]/100;r.Altitude[a[5]];let f=r.P2[n][0]-r.P0[n][0],p=((l+c)/2-u)/(f*f),m=((i+d)/2-u)/(f*f);r.Curvature[n]=2*(p+m)}return r}async function generateSquareMesh(){let e={positions:[[1,0,1],[1,0,-1],[-1,0,-1],[1,0,1],[-1,0,-1],[-1,0,1]],normals:[[1],[1],[1],[0],[0],[0]],uvs:[[1,0],[1,1],[0,1],[1,0],[0,1],[0,0]]};return console.log(e),e}async function getSquareMesh(){return await generateSquareMesh()}let CameraBase=class CameraBase{get matrix(){return this.matrix_}set matrix(e){a._E.copy(e,this.matrix_)}get view(){return this.view_}set view(e){a._E.copy(e,this.view_)}get right(){return this.right_}set right(e){a.R3.copy(e,this.right_)}get up(){return this.up_}set up(e){a.R3.copy(e,this.up_)}get back(){return this.back_}set back(e){a.R3.copy(e,this.back_)}get position(){return this.position_}set position(e){a.R3.copy(e,this.position_)}constructor(){this.matrix_=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.view_=a._E.create(),this.right_=new Float32Array(this.matrix_.buffer,0,4),this.up_=new Float32Array(this.matrix_.buffer,16,4),this.back_=new Float32Array(this.matrix_.buffer,32,4),this.position_=new Float32Array(this.matrix_.buffer,48,4)}};let WASDCamera=class WASDCamera extends CameraBase{get velocity(){return this.velocity_}set velocity(e){a.R3.copy(e,this.velocity_)}get matrix(){return super.matrix}set matrix(e){super.matrix=e,this.recalculateAngles(this.back)}update(e,t){var n,r,i,o;let sign=(e,t)=>(e?1:0)-(t?1:0);this.yaw-=t.analog.x*e*this.rotationSpeed,this.pitch-=t.analog.y*e*this.rotationSpeed,this.yaw=(n=this.yaw)-Math.floor(Math.abs(n)/(r=2*Math.PI))*r*Math.sign(n),this.pitch=Math.min(Math.max(this.pitch,-Math.PI/2),Math.PI/2);let s=a.R3.copy(this.position);super.matrix=a._E.rotateX(a._E.rotationY(this.yaw),this.pitch);let l=t.digital,u=sign(l.right,l.left),c=sign(l.up,l.down),d=a.R3.create(),f=sign(l.backward,l.forward);return a.R3.addScaled(d,this.right,u,d),a.R3.addScaled(d,this.up,c,d),a.R3.addScaled(d,this.back,f,d),a.R3.normalize(d,d),a.R3.mulScalar(d,this.movementSpeed,d),this.velocity=(i=this.velocity,o=Math.pow(1-this.frictionCoefficient,e),a.R3.addScaled(d,a.R3.sub(i,d),o)),this.position=a.R3.addScaled(s,this.velocity,e),this.view=a._E.invert(this.matrix),this.view}recalculateAngles(e){this.yaw=Math.atan2(e[0],e[2]),this.pitch=-Math.asin(e[1])}constructor(e){if(super(),this.pitch=0,this.yaw=0,this.velocity_=a.R3.create(),this.movementSpeed=150,this.rotationSpeed=1,this.frictionCoefficient=.99,e&&(e.position||e.target)){var t,n;let r=null!==(t=e.position)&&void 0!==t?t:a.R3.create(0,0,-5),i=null!==(n=e.target)&&void 0!==n?n:a.R3.create(0,0,0),o=a.R3.normalize(a.R3.sub(r,i));this.recalculateAngles(o),this.position=r}}};var w=n(7048);let y={p_ww:.75,p_wd:.4,p_i_w:.6},T=(0,w.hA)(),P=n(7686),S=-1,_="",getWeatherData=(e,t,n)=>{if(""===_)var a=Math.random()<y.p_i_w?"wet":"dry";else var a=_;let r=[];for(let e=0;e<t-1;e++){r[e]=[];for(let t=0;t<n-1;t++){let n=1+T(.01*e,.01*t);r[e][t]=n}}let i={temperature:[],precipitation:[]},o=[];for(let a=0;a<t;a++){o[a]=[];for(let t=0;t<n;t++){let n=(0,w.hA)(new P(e)),r=Math.max(.9*(1+n(.01*a,.01*t))+.2,0);o[a][t]=r}}for(let s=0;s<t-1;s++)for(let l=0;l<n-1;l++){let u=0;if("wet"===a){let e=2.5*Math.exp(2.5*Math.random())/24;u=e*o[s][l]}0===s&&0===l&&s==t-2&&l==n-2&&console.log("weather point 3");let c=-(9*Math.cos(2*getDayOfYear(e)*Math.PI/365))+(Math.random()-.5),d="wet"===a?-8:0,f=10+c+d+r[s][l];i.temperature[s*n+l]=f,i.precipitation[s*n+l]=u}return _="wet"===a?Math.random()<y.p_ww?"wet":"dry":"dry"===a&&Math.random()<y.p_wd?"wet":"dry",i};var C="src/sample/snowAccumulation/main.ts";let E={position:a.R3.create(-80,300,-100),target:a.R3.create(-180,330,-160)};function setCamera(e,t){let n=e||E.position,a=t||E.target;return new WASDCamera({position:n,target:a})}let init=async e=>{let t,n,r,{canvas:i,pageState:o,gui:s,stats:l}=e,u=await navigator.gpu.requestAdapter(),c=await u.requestDevice();if(!o.active)return;let d=i.getContext("webgpu");l.showPanel(0);let g=function(e,t){let n={forward:!1,backward:!1,left:!1,right:!1,up:!1,down:!1},a={x:0,y:0,zoom:0},r=!1,setDigital=(e,t)=>{switch(e.code){case"KeyW":n.forward=t,e.preventDefault(),e.stopPropagation();break;case"KeyS":n.backward=t,e.preventDefault(),e.stopPropagation();break;case"KeyA":n.left=t,e.preventDefault(),e.stopPropagation();break;case"KeyD":n.right=t,e.preventDefault(),e.stopPropagation();break;case"Space":n.up=t,e.preventDefault(),e.stopPropagation();break;case"ShiftLeft":case"ControlLeft":case"KeyC":n.down=t,e.preventDefault(),e.stopPropagation()}};return e.addEventListener("keydown",e=>setDigital(e,!0)),e.addEventListener("keyup",e=>setDigital(e,!1)),t.style.touchAction="pinch-zoom",t.addEventListener("pointerdown",()=>{r=!0}),t.addEventListener("pointerup",()=>{r=!1}),t.addEventListener("pointermove",e=>{(r="mouse"!=e.pointerType||(1&e.buttons)!=0)&&(a.x+=e.movementX,a.y+=e.movementY)}),t.addEventListener("wheel",e=>{(r=(1&e.buttons)!=0)&&(a.zoom+=Math.sign(e.deltaY),e.preventDefault(),e.stopPropagation())},{passive:!1}),()=>{let e={digital:n,analog:{x:a.x,y:a.y,zoom:a.zoom,touching:r}};return a.x=0,a.y=0,a.zoom=0,e}}(window,i),v=setCamera(),x={guiTemperature:0,guiPrecipitation:0,useGuiWeather:!0},b={showStats:!0,showMemoryUsage:!1};s.add({resetCamera(){v=setCamera()}},"resetCamera").name("Reset Camera"),s.add(x,"guiTemperature",-50,70).name("Temperature");let w=s.add(x,"guiPrecipitation",0,2.5).name("Precipitation");s.add(x,"useGuiWeather").name("Use Gui Weather"),w=w.step(.1),s.add(b,"showStats").name("Show Stats"),s.add(b,"showMemoryUsage").name("Memory Usage");let y=window.devicePixelRatio;i.width=i.clientWidth*y,i.height=i.clientHeight*y;let T=navigator.gpu.getPreferredCanvasFormat(),P=await createSkyboxPipeline(c,T);console.log("binding for skybox vertex buffer");let S=c.createBuffer({size:f.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(S.getMappedRange()).set(f),S.unmap(),console.log("done for binding for skybox vertex buffer");let _=c.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),C=await loadCubemapTexture(c),E=c.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge"}),B=c.createBindGroup({layout:P.getBindGroupLayout(0),label:"skybox group",entries:[{binding:0,resource:{buffer:_,size:64}},{binding:1,resource:E},{binding:2,resource:C.createView({dimension:"cube"})}]});console.log(B),d.configure({device:c,format:T,alphaMode:"premultiplied"}),c.createBuffer({size:0,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE});let A=await getTerrainMesh(),U=await getSquareMesh(),M=await getTerrainCells(A);console.log(M.Size);let D=[11*A.width+6,11*A.width+7,9*A.width+15,9*A.width+16,9*A.width+17,9*A.width+18,11*A.height+6,11*A.height+7,9*A.height+15,9*A.height+16,9*A.height+17,9*A.height+18];for(let e=0;e<D.length;e++){let t=D[e];console.log("Terrain Cell: "+t),console.log("Aspect:  "+M.Aspect[t]),console.log("Inclination:  "+M.Inclination[t]),console.log("Altitude:  "+M.Altitude[t]),console.log("Area:  "+M.Area[t]),console.log("AreaXZ:  "+M.AreaXZ[t])}let G=c.createBuffer({size:48*M.Size,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE,mappedAtCreation:!0});{let e=new Float32Array(G.getMappedRange());for(let t=0;t<M.Size;t++)e.set([M.Aspect[t],M.Inclination[t],M.Altitude[t],M.Latitude[t],M.Area[t],M.AreaXZ[t],M.SnowWaterEquivalent[t],M.InterpolatedSWE[t],M.SnowAlbedo[t],M.DaysSinceLastSnowfall[t],M.Curvature[t],0],12*t);G.unmap()}let R=c.createBuffer({size:16,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),I=c.createBuffer({label:"vertex buffer",size:6*U.positions.length*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});{let e=new Float32Array(I.getMappedRange());for(let t=0;t<U.positions.length;++t)e.set(U.positions[t],6*t),e.set(U.normals[t],6*t+3),e.set(U.uvs[t],6*t+4);I.unmap()}let L=[{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32"},{shaderLocation:2,offset:4*Float32Array.BYTES_PER_ELEMENT,format:"float32x2"}]}],O=c.createRenderPipeline({layout:"auto",vertex:{module:c.createShaderModule({code:p}),entryPoint:"vs_main",buffers:L},fragment:{module:c.createShaderModule({code:p}),entryPoint:"fs_main",targets:[{format:T}]},primitive:{topology:"triangle-list"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}}),z=c.createTexture({size:[i.width,i.height],format:"depth24plus-stencil8",usage:GPUTextureUsage.RENDER_ATTACHMENT}),k=c.createTexture({size:[A.width-1,A.height-1,1],format:"rgba32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),V=c.createBuffer({size:96,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});{let e=await fetch("../assets/img/file/k2-t.png"),n=await createImageBitmap(await e.blob());t=c.createTexture({size:[n.width,n.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),c.queue.copyExternalImageToTexture({source:n},{texture:t},[n.width,n.height])}{let e=await getHeightData("../assets/img/file/k2-h.tif");n=c.createTexture({size:[h[0],h[1],1],format:"r32float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),new Float32Array(e),c.queue.writeTexture({texture:n},e,{bytesPerRow:4*h[0]},{width:h[0],height:h[1]})}console.log("amount of mesh:"+(n.width-1)*(n.height-1));let F=new Float32Array([.7,.7]),N=c.createBuffer({label:"Grid Uniforms",size:F.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});c.queue.writeBuffer(N,0,F);let W=c.createBindGroup({layout:O.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:V}},{binding:1,resource:k.createView()},{binding:2,resource:t.createView()},{binding:3,resource:{buffer:N}},{binding:4,resource:n.createView()},{binding:5,resource:{buffer:R}}]}),q={colorAttachments:[{view:void 0,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:z.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilClearValue:0,stencilLoadOp:"clear",stencilStoreOp:"store"}},Y=c.createBuffer({size:48,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(Y.getMappedRange()).set([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),Y.unmap();let X=1,H=1,j=1;{let e=await fetch("../assets/img/webgpu.png"),t=await createImageBitmap(await e.blob());for(;X<t.width||H<t.height;)X*=2,H*=2,j++;r=c.createTexture({size:[t.width,t.height,1],mipLevelCount:j,format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),c.queue.copyExternalImageToTexture({source:t},{texture:r},[t.width,t.height])}{let e=c.createComputePipeline({layout:"auto",compute:{module:c.createShaderModule({code:m}),entryPoint:"import_level"}}),t=c.createComputePipeline({layout:"auto",compute:{module:c.createShaderModule({code:m}),entryPoint:"export_level"}}),n=c.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),a=c.createBuffer({size:X*H*4,usage:GPUBufferUsage.STORAGE}),i=c.createBuffer({size:X*H*4,usage:GPUBufferUsage.STORAGE});c.queue.writeBuffer(n,0,new Int32Array([X]));let o=c.createCommandEncoder();for(let s=0;s<j;s++){let l=X>>s,u=H>>s,d=0==s?e.getBindGroupLayout(0):t.getBindGroupLayout(0),f=c.createBindGroup({layout:d,entries:[{binding:0,resource:{buffer:n}},{binding:1,resource:{buffer:1&s?a:i}},{binding:2,resource:{buffer:1&s?i:a}},{binding:3,resource:r.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:s,mipLevelCount:1})}]});if(0==s){let t=o.beginComputePass();t.setPipeline(e),t.setBindGroup(0,f),t.dispatchWorkgroups(Math.ceil(l/64),u),t.end()}else{let e=o.beginComputePass();e.setPipeline(t),e.setBindGroup(0,f),e.dispatchWorkgroups(Math.ceil(l/64),u),e.end()}}c.queue.submit([o.finish()])}let Z={simulate:!0,deltaTime:.04},K=c.createBuffer({size:48,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),$=c.createComputePipeline({layout:"auto",compute:{module:c.createShaderModule({code:p}),entryPoint:"simulate"}}),J=c.createBindGroup({layout:$.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:K}},{binding:1,resource:{buffer:G,offset:0,size:48*M.Size}},{binding:2,resource:t.createView()},{binding:3,resource:k.createView({format:"rgba32float",dimension:"2d"})},{binding:4,resource:{buffer:R}}]}),Q=i.width/i.height,ee=a._E.perspective(2*Math.PI/5,Q,1,100),et=a._E.create(),en=a._E.create(),ea=a._E.perspective(2*Math.PI/5,Q,1,5e4),er=a._E.create(),ei=Date.now(),eo=Date.now(),es=getWeatherData(ei,2,2);requestAnimationFrame(function frame(){if(!o.active)return;let e=Date.now(),t=(e-ei)/1e3,r=e-eo;ei=e,b.showStats?b.showMemoryUsage?l.showPanel(2):l.showPanel(0):l.showPanel(3);let i=v.update(t,g()),s=a._E.clone(i);s[12]=0,s[13]=0,s[14]=0,Math.floor(r/1e3)>=1&&!x.useGuiWeather&&(console.log("day of year: "+getDayOfYear(e)),eo=e,console.log("weatherData: "+(es=getWeatherData(e,A.width,A.height)).temperature[0]+" : "+es.precipitation[0])),c.queue.writeBuffer(K,0,new Float32Array([Z.simulate?Z.deltaTime:0,0,0,0,100*Math.random(),100*Math.random(),1+Math.random(),1+Math.random(),x.useGuiWeather?x.guiTemperature:es.temperature[0],x.useGuiWeather?x.guiPrecipitation:es.precipitation[0],0,0])),a._E.identity(et),a._E.translate(et,a.R3.fromValues(0,0,-3),et),a._E.rotateX(et,-.2*Math.PI,et),a._E.multiply(ee,et,en);let u=function(e){let t=v.update(e,g());return a._E.multiply(ea,t,er),er}(t);c.queue.writeBuffer(V,0,u.buffer,u.byteOffset,u.byteLength),c.queue.writeBuffer(V,64,new Float32Array([et[0],et[4],et[8],0,et[1],et[5],et[9],0]));let f=new Uint32Array([0,0,0,0]);c.queue.writeBuffer(R,0,f.buffer,f.byteOffset,f.byteLength);let p=d.getCurrentTexture();q.colorAttachments[0].view=p.createView(),b.showStats&&l.begin();let m=c.createCommandEncoder();{let e=m.beginComputePass();e.setPipeline($),e.setBindGroup(0,J),e.dispatchWorkgroups(Math.ceil((A.width-1)/8),Math.ceil((A.height-1)/8)),e.end()}{let e=m.beginRenderPass(q);e.setPipeline(O),e.setBindGroup(0,W),e.setVertexBuffer(0,I),e.draw(6,(n.width-1)*(n.height-1)),renderSkybox(c,P,S,_,B,e,u),e.end()}c.queue.submit([m.finish()]),requestAnimationFrame(frame),b.showStats&&l.end()})};var main=()=>makeSample({name:"snowAccmulation",description:"This is real-time snow accumulation on terrein based on real data",gui:!0,stats:!0,init,sources:[{name:C.substring(28),contents:"import { mat4, vec3 } from 'wgpu-matrix';\nimport { makeSample, SampleInit } from '../../components/SampleLayout';\nimport { renderSkybox } from './skyboxPipeline';\nimport { cubeVertexArray, cubeVertexSize, cubeUVOffset, cubePositionOffset, cubeVertexCount } from '../../meshes/cube';\nimport { createSkyboxPipeline, loadCubemapTexture } from './skyboxPipeline';\n\n\nimport particleWGSL from './particle.wgsl';\nimport probabilityMapWGSL from './probabilityMap.wgsl';\nimport { getTerrainMesh, getTerrainCells } from '../../meshes/terrain';\nimport { getSquareMesh} from '../../meshes/square';\nimport { WASDCamera, cameraSourceInfo } from './camera';\nimport { createInputHandler, inputSourceInfo } from './input';\nimport { getWeatherData } from './weather';\nimport { getDayOfYear, getHourOfDay,degreesToRadians, timeToDays, timeToHours, getNumHoursPassed, getNumDaysPassed} from '../../meshes/utils';\nimport { computeSnowCPU } from './snowCompute';\nimport { max } from 'wgpu-matrix/dist/2.x/vec2-impl';\nimport { getHeightData, numberArray } from '../../meshes/geotiff-utils';\n\nconst numParticles = 0;\nconst particlePositionOffset = 0;\nconst particleColorOffset = 4 * 4;\nconst particleInstanceByteSize =\n  3 * 4 + // position\n  1 * 4 + // lifetime\n  4 * 4 + // color\n  3 * 4 + // velocity\n  1 * 4 + // padding\n  0;\n\nconst cellInstanceByteSize =\n  11 * 4 + // data\n  1 * 4 + // padding\n  0;\n\nconst cameraDefaults = {\n  position: vec3.create(-80, 300, -100),\n  target: vec3.create(-180, 330, -160),\n  // position: vec3.create(0, 5, -5),\n  // target: vec3.create(0, 0, 0),\n};\n\n\nfunction setCamera(position?, target?)\n{\n  const initialCameraPosition = position ? position : cameraDefaults.position;\n  const initialCameraTarget = target ? target : cameraDefaults.target;\n  return new WASDCamera({ position: initialCameraPosition, target: initialCameraTarget });\n}\n\n//let skyboxPipeline, skyboxVerticesBuffer, skyboxUniformBuffer, skyboxUniformBindGroup;\nconst init: SampleInit = async ({ canvas, pageState, gui, stats }) => {\n \n  const adapter = await navigator.gpu.requestAdapter();\n  const device = await adapter.requestDevice();\n\n  if (!pageState.active) return;\n  const context = canvas.getContext('webgpu') as GPUCanvasContext;\n  stats.showPanel(0);\n \n  // The input handler\n  const inputHandler = createInputHandler(window, canvas);\n\n  // Camera initialization\n  let camera = setCamera();\n  let guiTemperature = 0.0;\n  let guiPrecipitation = 0.0;\n\n  const cameraParams = \n  {\n    resetCamera() {\n      camera = setCamera();\n    }\n  };\n\n  const weatherParams = \n  {\n    guiTemperature: guiTemperature,\n    guiPrecipitation: guiPrecipitation,\n    useGuiWeather: true,\n  }\n\n  const statsParams =\n  {\n    showStats: true,\n    showMemoryUsage: false,\n  }\n\n  gui.add(cameraParams, 'resetCamera').name(\"Reset Camera\");\n  gui.add(weatherParams, 'guiTemperature', -50.0, 70.0).name(\"Temperature\");\n  let precipController = gui.add(weatherParams, 'guiPrecipitation', 0.0, 2.5).name(\"Precipitation\");\n  gui.add(weatherParams, 'useGuiWeather').name(\"Use Gui Weather\");\n  precipController = precipController.step(0.1);\n\n  gui.add(statsParams, 'showStats').name(\"Show Stats\");\n  gui.add(statsParams, 'showMemoryUsage').name(\"Memory Usage\");\n\n  const devicePixelRatio = window.devicePixelRatio;\n  canvas.width = canvas.clientWidth * devicePixelRatio;\n  canvas.height = canvas.clientHeight * devicePixelRatio;\n  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n  \n  // Setup skybox pipeline here\n  //skyboxPipeline = await createSkyboxPipeline(device, presentationFormat);\n  // Initialize the skybox pipeline\n  //const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n\n  \n    // Initialize the skybox pipeline\n    const skyboxPipeline = await createSkyboxPipeline(device, presentationFormat);\n\n    // Initialize the vertex buffer for the skybox\n    console.log(\"binding for skybox vertex buffer\");\n    const skyboxVerticesBuffer = device.createBuffer({\n      size: cubeVertexArray.byteLength,\n      usage: GPUBufferUsage.VERTEX,\n      mappedAtCreation: true,\n    });\n    new Float32Array(skyboxVerticesBuffer.getMappedRange()).set(cubeVertexArray);\n    skyboxVerticesBuffer.unmap();\n    console.log(\"done for binding for skybox vertex buffer\");\n    // Initialize the uniform buffer for the skybox\n    const skyboxUniformBuffer = device.createBuffer({\n      size: 16 * 4,  // Size for 2 4x4 matrices (view and projection)\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n  \n    // Load the cubemap texture for the skybox\n    const cubemapTexture = await loadCubemapTexture(device);\n  \n    // Create a sampler for the cubemap texture\n    const cubemapSampler = device.createSampler({\n      magFilter: 'linear',\n      minFilter: 'linear',\n      mipmapFilter: 'linear',\n      addressModeU: 'clamp-to-edge',\n      addressModeV: 'clamp-to-edge',\n      addressModeW: 'clamp-to-edge',\n    });\n  \n    // Initialize the uniform bind group for the skybox\n    const skyboxUniformBindGroup = device.createBindGroup({\n      layout: skyboxPipeline.getBindGroupLayout(0),\n      label: \"skybox group\",\n      entries: [\n        { binding: 0, resource: { buffer: skyboxUniformBuffer,size: 4*16,} },\n        { binding: 1, resource: cubemapSampler },\n        { binding: 2, resource: cubemapTexture.createView({\n          dimension: 'cube',\n        }) },\n      ],\n    });\n    console.log(skyboxUniformBindGroup);\n  \n  context.configure({\n    device,\n    format: presentationFormat,\n    alphaMode: 'premultiplied',\n  });\n\n  const particlesBuffer = device.createBuffer({\n    size: numParticles * particleInstanceByteSize,\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE,\n  });\n\n  \n\n  const mesh=await getTerrainMesh();\n  const smesh=await getSquareMesh();\n  const terrainCells = await getTerrainCells(mesh);\n  console.log(terrainCells.Size);\n  \n  const terrainCellsDebugIndex = [11 * mesh.width + 6, 11 * mesh.width + 7, 9 * mesh.width + 15,\n                                  9 * mesh.width + 16, 9 * mesh.width + 17, 9 * mesh.width + 18,\n                                  11 * mesh.height + 6, 11 * mesh.height + 7, 9 * mesh.height + 15,\n                                  9 * mesh.height + 16, 9 * mesh.height + 17, 9 * mesh.height + 18,]\n\n  // for (let i = 0; i < 580; i += 20) {\n  for (let i = 0; i < terrainCellsDebugIndex.length; i++) {\n    const currIndex = terrainCellsDebugIndex[i];\n    console.log(\"Terrain Cell: \" + currIndex)\n    // console.log(\"P0: \" + i + \" \" + terrainCells.P0[i]);\n    // console.log(\"P1: \" + i + \" \" + terrainCells.P1[i]);\n    // console.log(\"P2: \" + i + \" \" + terrainCells.P2[i]);\n    // console.log(\"P3: \" + i + \" \" + terrainCells.P3[i]);\n    console.log(\"Aspect: \" + \" \" + terrainCells.Aspect[currIndex]);\n    console.log(\"Inclination: \" + \" \" + terrainCells.Inclination[currIndex]);\n    console.log(\"Altitude: \" + \" \" + terrainCells.Altitude[currIndex]);\n    // console.log(\"Latitude: \" + i + \" \" + terrainCells.Latitude[i]);\n    console.log(\"Area: \" + \" \" + terrainCells.Area[currIndex]);\n    console.log(\"AreaXZ: \" + \" \" + terrainCells.AreaXZ[currIndex]);\n    // console.log(\"SnowWaterEquivalent: \" + i + \" \" + terrainCells.SnowWaterEquivalent[i]);\n    // console.log(\"InterpolatedSWE: \" + i + \" \" + terrainCells.InterpolatedSWE[i]);\n    // console.log(\"SnowAlbedo: \" + i + \" \" + terrainCells.SnowAlbedo[i]);\n    // console.log(\"DaysSinceLastSnowfall: \" + i + \" \" + terrainCells.DaysSinceLastSnowfall[i]);\n    // console.log(\"Curvature: \" + i + \" \" + terrainCells.Curvature[i]);\n  // }\n  }\n  const cellBuffer = device.createBuffer({\n    size: terrainCells.Size * cellInstanceByteSize,\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE,\n    mappedAtCreation: true,\n  });\n  {\n    const mapping = new Float32Array(cellBuffer.getMappedRange());\n    for (let i = 0; i < terrainCells.Size; i++){\n      mapping.set([\n        terrainCells.Aspect[i],\n        terrainCells.Inclination[i],\n        terrainCells.Altitude[i],\n        terrainCells.Latitude[i],\n        terrainCells.Area[i],\n        terrainCells.AreaXZ[i],\n        terrainCells.SnowWaterEquivalent[i],\n        terrainCells.InterpolatedSWE[i],\n        terrainCells.SnowAlbedo[i],\n        terrainCells.DaysSinceLastSnowfall[i],\n        terrainCells.Curvature[i],\n        0.0,\n      ],i*12);\n    }\n    cellBuffer.unmap();\n  }\n      \n    const maxBuffer = device.createBuffer({\n      size: 4 * 4,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      // mappedAtCreation: true,\n    });\n    // {\n    //   const mapping = new Int32Array(maxBuffer.getMappedRange());\n    //   mapping.set([0,0,0,0]);\n    //   maxBuffer.unmap();\n    // }\n  \n  \n  /*const indexCount = smesh.triangles.length * 3;\n  console.log(\"buffer size\"+indexCount * Uint16Array.BYTES_PER_ELEMENT);\n  console.log(\"mesh.triangles.length: \" + smesh.triangles.length)*/\n  /*const indexBuffer = device.createBuffer({\n    label: \"index buffer\",\n    size: indexCount * Uint16Array.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.INDEX,\n    mappedAtCreation: true,\n  });\n  {\n    const mapping = new Uint16Array(indexBuffer.getMappedRange());\n    for (let i = 0; i < smesh.triangles.length; ++i) {\n      mapping.set(smesh.triangles[i], 3 * i);\n    }\n    indexBuffer.unmap();\n  }*/\n  const vertexBuffer = device.createBuffer({\n    label: \"vertex buffer\",\n    size: smesh.positions.length * 6 * Float32Array.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true,\n  });\n  \n  {\n    const mapping = new Float32Array(vertexBuffer.getMappedRange());\n    for (let i = 0; i < smesh.positions.length; ++i) {\n      mapping.set(smesh.positions[i], 6 * i);\n      mapping.set(smesh.normals[i], 6 * i + 3);\n      mapping.set(smesh.uvs[i], 6 * i+4);\n    }\n    vertexBuffer.unmap();\n  }\n  const vertexBuffers: Iterable<GPUVertexBufferLayout> = [\n    {\n      arrayStride: Float32Array.BYTES_PER_ELEMENT * 6,\n      attributes: [\n        {\n          // position\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float32x3',\n        },\n        {\n          // normal\n          shaderLocation: 1,\n          offset: Float32Array.BYTES_PER_ELEMENT * 3,\n          format: 'float32',\n        },\n        {\n          // uv\n          shaderLocation: 2,\n          offset: Float32Array.BYTES_PER_ELEMENT * 4,\n          format: 'float32x2',\n        },\n      ],\n    },\n  ];\n\n  // not needed\n  // const renderPipelineBindGroupLayout = device.createBindGroupLayout({\n  //   entries: [\n  //     {\n  //       binding: 0,\n  //       visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n  //       buffer : {}\n  //     },\n  //     {\n  //       binding: 1,\n  //       visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n  //       texture: {}\n  //     },\n  //     {\n  //       binding: 2,\n  //       visibility: GPUShaderStage.FRAGMENT,\n  //       texture: {}\n  //     },\n  //     {\n  //       binding: 3,\n  //       visibility: GPUShaderStage.FRAGMENT,\n  //       buffer: {}\n  //     },\n  //   ],\n  // });\n\n  // const renderPipelineLayout = device.createPipelineLayout({\n  //   bindGroupLayouts: [\n  //     renderPipelineBindGroupLayout, // @group(0)\n  //   ]\n  // });\n\n  const renderPipeline = device.createRenderPipeline({\n    layout: 'auto',\n    vertex: {\n      module: device.createShaderModule({\n        code: particleWGSL,\n      }),\n      entryPoint: 'vs_main',\n      buffers: vertexBuffers,\n    },\n    fragment: {\n      module: device.createShaderModule({\n        code: particleWGSL,\n      }),\n      entryPoint: 'fs_main',\n      targets: [\n        {\n          format: presentationFormat,\n        },\n      ],\n    },\n    primitive: {\n      topology: 'triangle-list',\n      //cullMode: 'back',\n    },\n\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'less',\n      format: 'depth24plus-stencil8',\n    },\n  });\n\n  const depthTexture = device.createTexture({\n    size: [canvas.width, canvas.height],\n    format: 'depth24plus-stencil8',\n    usage: GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n  const writableTexture = device.createTexture({\n    size: [mesh.width-1, mesh.height-1, 1],\n    format: 'rgba32float', // Adjust based on your requirements\n    usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.STORAGE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n  const uniformBufferSize =\n    4 * 4 * 4 + // modelViewProjectionMatrix : mat4x4<f32>\n    3 * 4 + // right : vec3<f32>\n    4 + // padding\n    3 * 4 + // up : vec3<f32>\n    4 + // padding\n    0;\n  const uniformBuffer = device.createBuffer({\n    size: uniformBufferSize,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n  let cubeTexture: GPUTexture;\n  {\n    const response = await fetch('../assets/img/file/k2-t.png');\n    //const response = await fetch('../assets/img/Di-3d.png');\n    const imageBitmap = await createImageBitmap(await response.blob());\n\n    cubeTexture = device.createTexture({\n      size: [imageBitmap.width, imageBitmap.height, 1],\n      format: 'rgba8unorm',\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    device.queue.copyExternalImageToTexture(\n      { source: imageBitmap },\n      { texture: cubeTexture },\n      [imageBitmap.width, imageBitmap.height]\n    );\n  }\n  /*let heightTexture: GPUTexture;\n  {\n    const response = await fetch('../assets/img/file/height1.png');\n    //const response = await fetch('../assets/img/Di-3d.png');\n    const imageBitmap = await createImageBitmap(await response.blob());\n\n    heightTexture = device.createTexture({\n      size: [imageBitmap.width, imageBitmap.height, 1],\n      format: 'rgba8unorm',\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    device.queue.copyExternalImageToTexture(\n      { source: imageBitmap },\n      { texture: heightTexture },\n      [imageBitmap.width, imageBitmap.height]\n    );\n  }*/\n  \n  let heightTexture: GPUTexture;\n  {\n    //const response = await fetch('../assets/img/file/k2-h.tif');\n    //const response = await fetch('../assets/img/Di-3d.png');\n    //const url = '../assets/img/file/everest.tif';\n    const url = '../assets/img/file/k2-h.tif';\n    const heightData = await getHeightData(url);\n    \n    heightTexture = device.createTexture({\n      size: [numberArray[0], numberArray[1],1],\n      format: \"r32float\",\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    const arrayBuffer = new Float32Array(heightData);\n    device.queue.writeTexture(\n      { texture: heightTexture },\n      heightData,\n      {bytesPerRow:numberArray[0]*4},\n      { width: numberArray[0], height: numberArray[1] }\n    );\n  }\n  console.log(\"amount of mesh:\"+(heightTexture.width-1)*(heightTexture.height-1));\n  //heightTexture=cubeTexture;\n  const uniformArray = new Float32Array([0.7, 0.7]);\n  const gridBuffer = device.createBuffer({\n    label: \"Grid Uniforms\",\n    size: uniformArray.byteLength,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n  device.queue.writeBuffer(gridBuffer, 0, uniformArray);\n  const uniformBindGroup = device.createBindGroup({\n    layout: renderPipeline.getBindGroupLayout(0),\n    entries: [\n      {\n        binding: 0,\n        resource: {\n          buffer: uniformBuffer,\n        },\n      },\n      {\n        binding: 1,\n        resource: writableTexture.createView(),\n      },\n      {\n        binding: 2,\n        resource: cubeTexture.createView(),\n      },\n      {\n        binding: 3,\n        resource: {\n          buffer: gridBuffer,\n        }\n      },\n      {\n        binding: 4,\n        resource: heightTexture.createView(),\n      },\n      {\n        binding: 5,\n        resource: {\n          buffer: maxBuffer,\n        }\n      }\n    ],\n  });\n\n  const renderPassDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [\n      {\n        view: undefined, // Assigned later\n        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n        loadOp: 'clear',\n        storeOp: 'store',\n      },\n    ],\n    depthStencilAttachment: {\n      view: depthTexture.createView(),\n\n      depthClearValue: 1.0,\n      depthLoadOp: 'clear',\n      depthStoreOp: 'store',\n      stencilClearValue: 0,\n      stencilLoadOp: 'clear',\n      stencilStoreOp: 'store',\n    },\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Quad vertex buffer\n  //////////////////////////////////////////////////////////////////////////////\n  const quadVertexBuffer = device.createBuffer({\n    size: 6 * 2 * 4, // 6x vec2<f32>\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true,\n  });\n  // prettier-ignore\n  const vertexData = [\n    -1.0, -1.0, +1.0, -1.0, -1.0, +1.0, -1.0, +1.0, +1.0, -1.0, +1.0, +1.0,\n  ];\n  new Float32Array(quadVertexBuffer.getMappedRange()).set(vertexData);\n  quadVertexBuffer.unmap();\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Texture\n  //////////////////////////////////////////////////////////////////////////////\n  \n  \n  let texture: GPUTexture;\n  let textureWidth = 1;\n  let textureHeight = 1;\n  let numMipLevels = 1;\n  {\n    const response = await fetch('../assets/img/webgpu.png');\n    const imageBitmap = await createImageBitmap(await response.blob());\n\n    // Calculate number of mip levels required to generate the probability map\n    while (\n      textureWidth < imageBitmap.width ||\n      textureHeight < imageBitmap.height\n    ) {\n      textureWidth *= 2;\n      textureHeight *= 2;\n      numMipLevels++;\n    }\n    texture = device.createTexture({\n      size: [imageBitmap.width, imageBitmap.height, 1],\n      mipLevelCount: numMipLevels,\n      format: 'rgba8unorm',\n      usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.STORAGE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    device.queue.copyExternalImageToTexture(\n      { source: imageBitmap },\n      { texture: texture },\n      [imageBitmap.width, imageBitmap.height]\n    );\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Probability map generation\n  // The 0'th mip level of texture holds the color data and spawn-probability in\n  // the alpha channel. The mip levels 1..N are generated to hold spawn\n  // probabilities up to the top 1x1 mip level.\n  //////////////////////////////////////////////////////////////////////////////\n  {\n    const probabilityMapImportLevelPipeline = device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: device.createShaderModule({ code: probabilityMapWGSL }),\n        entryPoint: 'import_level',\n      },\n    });\n    const probabilityMapExportLevelPipeline = device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: device.createShaderModule({ code: probabilityMapWGSL }),\n        entryPoint: 'export_level',\n      },\n    });\n\n    const probabilityMapUBOBufferSize =\n      1 * 4 + // stride\n      3 * 4 + // padding\n      0;\n    const probabilityMapUBOBuffer = device.createBuffer({\n      size: probabilityMapUBOBufferSize,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    const buffer_a = device.createBuffer({\n      size: textureWidth * textureHeight * 4,\n      usage: GPUBufferUsage.STORAGE,\n    });\n    const buffer_b = device.createBuffer({\n      size: textureWidth * textureHeight * 4,\n      usage: GPUBufferUsage.STORAGE,\n    });\n    device.queue.writeBuffer(\n      probabilityMapUBOBuffer,\n      0,\n      new Int32Array([textureWidth])\n    );\n    const commandEncoder = device.createCommandEncoder();\n    for (let level = 0; level < numMipLevels; level++) {\n      const levelWidth = textureWidth >> level;\n      const levelHeight = textureHeight >> level;\n      const pipeline =\n        level == 0\n          ? probabilityMapImportLevelPipeline.getBindGroupLayout(0)\n          : probabilityMapExportLevelPipeline.getBindGroupLayout(0);\n      const probabilityMapBindGroup = device.createBindGroup({\n        layout: pipeline,\n        entries: [\n          {\n            // ubo\n            binding: 0,\n            resource: { buffer: probabilityMapUBOBuffer },\n          },\n          {\n            // buf_in\n            binding: 1,\n            resource: { buffer: level & 1 ? buffer_a : buffer_b },\n          },\n          {\n            // buf_out\n            binding: 2,\n            resource: { buffer: level & 1 ? buffer_b : buffer_a },\n          },\n          {\n            // tex_in / tex_out\n            binding: 3,\n            resource: texture.createView({\n              format: 'rgba8unorm',\n              dimension: '2d',\n              baseMipLevel: level,\n              mipLevelCount: 1,\n            }),\n          },\n        ],\n      });\n      if (level == 0) {\n        const passEncoder = commandEncoder.beginComputePass();\n        passEncoder.setPipeline(probabilityMapImportLevelPipeline);\n        passEncoder.setBindGroup(0, probabilityMapBindGroup);\n        passEncoder.dispatchWorkgroups(Math.ceil(levelWidth / 64), levelHeight);\n        passEncoder.end();\n      } else {\n        const passEncoder = commandEncoder.beginComputePass();\n        passEncoder.setPipeline(probabilityMapExportLevelPipeline);\n        passEncoder.setBindGroup(0, probabilityMapBindGroup);\n        passEncoder.dispatchWorkgroups(Math.ceil(levelWidth / 64), levelHeight);\n        passEncoder.end();\n      }\n    }\n    device.queue.submit([commandEncoder.finish()]);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Simulation compute pipeline\n  //////////////////////////////////////////////////////////////////////////////\n  const simulationParams = {\n    simulate: true,\n    deltaTime: 0.04,\n  };\n\n  const simulationUBOBufferSize =\n    1 * 4 + // deltaTime\n    3 * 4 + // padding\n    4 * 4 + // seed\n    4 * 4 + //temp+perci\n    0;\n  const simulationUBOBuffer = device.createBuffer({\n    size: simulationUBOBufferSize,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n\n  /*Object.keys(simulationParams).forEach((k) => {\n    gui.add(simulationParams, k);\n  });*/\n\n  const computePipeline = device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: device.createShaderModule({\n        code: particleWGSL,\n      }),\n      entryPoint: 'simulate',\n    },\n  });\n  const computeBindGroup = device.createBindGroup({\n    layout: computePipeline.getBindGroupLayout(0),\n    entries: [\n      {\n        binding: 0,\n        resource: {\n          buffer: simulationUBOBuffer,\n        },\n      },\n      {\n        binding: 1,\n        resource: {\n          buffer: cellBuffer,\n          offset: 0,\n          size: terrainCells.Size * cellInstanceByteSize,\n        },\n      },\n      {\n        binding: 2,\n        resource: cubeTexture.createView(),\n      },\n      {\n        binding: 3,\n        //resource: cubeTexture.createView(),\n        resource: writableTexture.createView({\n            format: 'rgba32float',\n            dimension: '2d',\n          }\n        ),\n      },\n      {\n        binding: 4,\n        resource: {\n          buffer: maxBuffer,\n        }\n      },\n    ],\n  });\n\n  const aspect = canvas.width / canvas.height;\n  const projection = mat4.perspective((2 * Math.PI) / 5, aspect, 1, 100.0);\n  const view = mat4.create();\n  const mvp = mat4.create();\n\n  const projectionMatrix = mat4.perspective(\n    (2 * Math.PI) / 5,\n    aspect,\n    1,\n    50000.0\n  );\n\n  const modelViewProjectionMatrix = mat4.create();\n\n  function getModelViewProjectionMatrix(deltaTime: number) {\n    const viewMatrix = camera.update(deltaTime, inputHandler());\n    mat4.multiply(projectionMatrix, viewMatrix, modelViewProjectionMatrix);\n    return modelViewProjectionMatrix as Float32Array;\n  }\n\n  let lastFrameMS = Date.now();\n  let lastDayMS = Date.now()\n  let weatherData = getWeatherData(lastFrameMS, 2, 2);\n\n  function frame() {\n    // Sample is no longer the active page.\n    // console.log(\"loading\");\n    if (!pageState.active) return;\n    const now = Date.now();\n    const deltaTime = (now - lastFrameMS) / 1000;\n    const deltaTimeFull = now - lastDayMS;\n    lastFrameMS = now;\n    if (statsParams.showStats)\n    {\n      if (statsParams.showMemoryUsage)\n      {\n        stats.showPanel(2);\n      }\n      else\n      {\n        stats.showPanel(0);\n      }\n    }\n    else\n    {\n      stats.showPanel(3)\n    }\n\n\n    // Update camera\n    const viewMatrix = camera.update(deltaTime, inputHandler());\n\n    // Render skybox\n    const skyboxViewMatrix = mat4.clone(viewMatrix);\n    skyboxViewMatrix[12] = 0; // Remove translation component\n    skyboxViewMatrix[13] = 0;\n    skyboxViewMatrix[14] = 0;\n    \n\n    //const viewMatrix = camera.update(deltaTime, inputHandler());\n    // Render the skybox\n    //renderSkybox(device, canvas, viewMatrix, projectionMatrix);\n    //TODO: how to bind weather Data per frame\n    if (getNumDaysPassed(deltaTimeFull) >= 1 && !weatherParams.useGuiWeather)\n    {\n      console.log(\"day of year: \" + getDayOfYear(now));\n      lastDayMS = now;\n      weatherData = getWeatherData(now, mesh.width, mesh.height);\n      console.log(\"weatherData: \" + weatherData.temperature[0] + \" : \" + weatherData.precipitation[0]);\n\n    }\n\n    if (now % 1000 > 998)\n    {\n      // weatherData = getWeatherData(now, mesh.width, mesh.height);\n      \n      // for (let i = 0; i < 10; i++) {\n      //   console.log(\"now: \" + now);\n      //   console.log(\"day of year: \" + getDayOfYear(now));\n      //   console.lSog(\"weather for cell: \" + (i * 20));\n        // console.log(\"temperature: \" + weatherData.temperature[i * 20]);\n        // console.log(\"temperature: \" + weatherData.temperature[20]);\n      //   console.log(\"precipitation: \" + weatherData.precipitation[i * 20]);\n      // }\n    }\n\n    device.queue.writeBuffer(\n      simulationUBOBuffer,\n      0,\n      new Float32Array([\n        simulationParams.simulate ? simulationParams.deltaTime : 0.0,\n        0.0,\n        0.0,\n        0.0, // padding\n        Math.random() * 100,\n        Math.random() * 100, // seed.xy\n        1 + Math.random(),\n        1 + Math.random(), // seed.zw\n        weatherParams.useGuiWeather ? weatherParams.guiTemperature : weatherData.temperature[0], //TODO: bind weather Data temperature per frame\n        weatherParams.useGuiWeather ? weatherParams.guiPrecipitation : weatherData.precipitation[0], //TODO: bind weather Data percipitation per frame\n        //getHourOfDay(now),//padding\n        //getDayOfYear(now),\n        0.0,\n        0.0,\n      ])\n    );\n    // if (now % 1000 > 998)\n    // {\n    //   if (weatherParams.useGuiWeather)\n    //   {\n    //     console.log(\"use gui weather\");\n    //     computeSnowCPU(terrainCells, weatherParams.guiTemperature, weatherParams.guiPrecipitation)\n    //   }\n    //   else\n    //   {\n    //     computeSnowCPU(terrainCells);\n    //   }\n    // }\n\n    mat4.identity(view);\n    mat4.translate(view, vec3.fromValues(0, 0, -3), view);\n    mat4.rotateX(view, Math.PI * -0.2, view);\n    mat4.multiply(projection, view, mvp);\n\n    const cameraViewProj = getModelViewProjectionMatrix(deltaTime);\n    device.queue.writeBuffer(\n      uniformBuffer,\n      0,\n      cameraViewProj.buffer,\n      cameraViewProj.byteOffset,\n      cameraViewProj.byteLength\n    )\n\n    // prettier-ignore\n    device.queue.writeBuffer(\n      uniformBuffer,\n      64,\n      new Float32Array([\n        // modelViewProjectionMatrix\n        // mvp[0], mvp[1], mvp[2], mvp[3],\n        // mvp[4], mvp[5], mvp[6], mvp[7],\n        // mvp[8], mvp[9], mvp[10], mvp[11],\n        // mvp[12], mvp[13], mvp[14], mvp[15],\n\n        view[0], view[4], view[8], // right\n\n        0, // padding\n\n        view[1], view[5], view[9], // up\n\n        0, // padding\n      ])\n    );\n\n    let maxArray = new Uint32Array([0,0,0,0]);\n\n    device.queue.writeBuffer(\n      maxBuffer,\n      0,\n      maxArray.buffer,\n      maxArray.byteOffset,\n      maxArray.byteLength\n    );\n    \n    const swapChainTexture = context.getCurrentTexture();\n    // prettier-ignore\n    renderPassDescriptor.colorAttachments[0].view = swapChainTexture.createView();\n    \n    if (statsParams.showStats) {\n      stats.begin();\n    }\n\n      \n    const commandEncoder = device.createCommandEncoder();\n    \n    {\n      const passEncoder = commandEncoder.beginComputePass();\n      passEncoder.setPipeline(computePipeline);\n      passEncoder.setBindGroup(0, computeBindGroup);\n      passEncoder.dispatchWorkgroups(Math.ceil((mesh.width-1) / 8),Math.ceil((mesh.height-1) / 8));\n      passEncoder.end();\n    }\n    {\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setPipeline(renderPipeline);\n      passEncoder.setBindGroup(0, uniformBindGroup);\n      passEncoder.setVertexBuffer(0, vertexBuffer);\n      //passEncoder.setIndexBuffer(indexBuffer, 'uint16');\n      passEncoder.draw(6,(heightTexture.width-1)*(heightTexture.height-1));//(heightTexture.width-1)*(heightTexture.height-1)\n      // passEncoder.setIndexBuffer(indexBuffer, 'uint16');\n      // passEncoder.drawIndexed(indexCount);\n      renderSkybox(device, skyboxPipeline, skyboxVerticesBuffer, skyboxUniformBuffer, skyboxUniformBindGroup,passEncoder,cameraViewProj);\n      passEncoder.end();\n    }\n    \n    device.queue.submit([commandEncoder.finish()]);\n\n    requestAnimationFrame(frame);\n    if (statsParams.showStats) {\n      stats.end()\n    }\n  }\n  requestAnimationFrame(frame);\n};\n\nconst Particles: () => JSX.Element = () =>\n  makeSample({\n    name: 'snowAccmulation',\n    description:\n      'This is real-time snow accumulation on terrein based on real data',\n    gui: true,\n    stats: true,\n    init,\n    sources: [\n      {\n        name: __filename.substring(__dirname.length + 1),\n        contents: __SOURCE__,\n      },\n      {\n        name: './particle.wgsl',\n        contents: particleWGSL,\n        editable: true,\n      },\n      {\n        name: './probabilityMap.wgsl',\n        contents: probabilityMapWGSL,\n        editable: true,\n      },\n    ],\n    filename: __filename,\n  });\n\nexport default Particles;"},{name:"./particle.wgsl",contents:p,editable:!0},{name:"./probabilityMap.wgsl",contents:m,editable:!0}],filename:C})},4131:function(e){e.exports={canvasContainer:"SampleLayout_canvasContainer__ZTWP5",sourceFileNav:"SampleLayout_sourceFileNav__9Hf73",sourceFileContainer:"SampleLayout_sourceFileContainer__9iti6"}}}]);